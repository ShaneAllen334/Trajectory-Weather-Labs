/**
 * TRAJECTORY WEATHER LABS
 * ---------------------------------------------------------------------------------
 * "Predict the surge. Control the outcome."
 */

definition(
    name: "Trajectory Weather Labs",
    namespace: "user",
    author: "ShaneAllen",
    description: "Professional-grade meteorological engine using Linear Trend Extrapolation and Forensic DNA to predict storms, floods, and frost 1 hour ahead.",
    category: "Convenience",
    // [NEW] HPM COMPATIBILITY PARAMETERS
    // UPDATE THESE URLS TO MATCH YOUR GITHUB REPO LOCATION
    importUrl: "https://github.com/ShaneAllen334/Trajectory-Weather-Labs/blob/main/Trajectory%20Weather%20Labs%20V5.txt",
    documentationLink: "",
    iconUrl: "", iconX2Url: ""
)

preferences {
    page(name: "mainPage")
    page(name: "configurePage")
    page(name: "calibrationPage")
    // Sub-Pages for Calibration
    page(name: "stormConfigPage")
    page(name: "floodConfigPage")
    page(name: "frostConfigPage")
    // [NEW] Regional Physics Page
    page(name: "regionConfigPage")
    page(name: "weightConfigPage")
  
    page(name: "systemConfigPage")
    
    page(name: "trustPage")
    page(name: "predictiveMathPage")
    page(name: "forensicMathPage")
    page(name: "dataLogPage")
}

// =================================================================================================
// 1. LIFECYCLE & INITIALIZATION
// =================================================================================================

def installed() { 
    state.setupComplete = true
    initialize() 
}

def updated() { 
    unschedule() 
    initialize()
    
    // [NEW] Dynamic Polling Interval
    def interval = (pollInterval ?: "15").toInteger()
    if (interval == 1) runEvery1Minute("pollWeatherStation")
    else if (interval == 5) runEvery5Minutes("pollWeatherStation")
    else if (interval == 10) runEvery10Minutes("pollWeatherStation")
    else if (interval == 15) runEvery15Minutes("pollWeatherStation")
    else if (interval == 30) runEvery30Minutes("pollWeatherStation")
    else schedule("0 */${interval} * * * ?", "pollWeatherStation") // 45, 60
    
    // Run immediately
    runIn(2, "pollWeatherStation") 
}

def uninstalled() {
    unschedule()
    state.clear()
    log.info "Trajectory Weather Labs: Application uninstalled. All logs, history, and state variables have been wiped."
}

def initialize() {
    // 1. Initialize PAI
    if (state.paiStorm == null) { 
        state.paiStorm=100;
        state.paiStormWhy="Nominal"; 
        state.paiFlood=100; state.paiFloodWhy="Nominal"; 
        state.paiFrost=100; state.paiFrostWhy="Nominal" 
    }
    
    // 2. Initialize History Arrays
    if (!state.histTemp) state.histTemp=[]
    if (!state.histHum) state.histHum=[]
    if (!state.histGust) state.histGust=[]
    if (!state.histWind) state.histWind=[]
    if (!state.histRain) state.histRain=[]
    if (!state.histDew) state.histDew=[]
    if (!state.histChill) state.histChill=[]
    if (!state.histLight) state.histLight=[]
    if (!state.histSat) state.histSat=[]
    if (!state.histBat) state.histBat=[]
    if (!state.histLux) state.histLux=[]
    if (!state.anomalies) state.anomalies=[]
    
    // [NEW] Score History for Countdown Timers
    if (!state.histStormScore) state.histStormScore=[]
    if (!state.histFloodScore) state.histFloodScore=[]
    if (!state.histFrostScore) state.histFrostScore=[]
    
    // 3. Initialize Operational Flags
    if (!state.alertHistory) state.alertHistory = []
    if (!state.activeEventStart) state.activeEventStart = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]
    
    // 4. Initialize Physics Variables
    if (state.dayHighTemp == null) state.dayHighTemp = -999
    if (state.dayLowTemp == null) state.dayLowTemp = 999
    if (state.dayHighGust == null) state.dayHighGust = 0
    if (state.dayHighWind == null) state.dayHighWind = 0
    if (state.lockedGust == null) state.lockedGust = 0.0
    if (state.lockedWind == null) state.lockedWind = 0.0
  
    if (state.wetBulb == null) state.wetBulb = 0.0
    
    // 5. Initialize Weights (Prevent Calculation Errors)
    if (state.wGustWeight == null) state.wGustWeight = 0
    if (state.wSpeedWeight == null) state.wSpeedWeight = 0
    if (state.sRainWeight == null) state.sRainWeight = 0
    if (state.lWeight == null) state.lWeight = 0
    if (state.proxWeight == null) state.proxWeight = 0
    if (state.dWeight == null) state.dWeight = 0
    if (state.luxWeight == null) state.luxWeight = 0
    if (state.wDirWeight == null) state.wDirWeight = 0
    if (state.frrWeight == null) state.frrWeight = 0
    if (state.fsWeight == null) state.fsWeight = 0
    if (state.fTempWeight == null) state.fTempWeight = 0
    if (state.fHumWeight == null) state.fHumWeight = 0
    if (state.tWeightDrop == null) state.tWeightDrop = 0
    if (state.fDirWeight == null) state.fDirWeight = 0

    // Forecast Map
    if (!state.forecast) state.forecast = [storm:[status:"STABLE", color:"#43a047"], flood:[status:"STABLE", color:"#43a047"], frost:[status:"STABLE", color:"#43a047"], predT:0, predH:0, predD:0, predW:0, predG:0, predR:0]
    
    // Timers
    if (!state.lastTriggerTime) state.lastTriggerTime = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]

    state.narrative = "INITIALIZING SENSORS..."
    state.lightningStale = false 
    state.stormOverrideActive = false
    
    // Test Mode Resets
    state.testMode=false;
    state.testStorm=false; state.testFlood=false; state.testFrost=false; state.simulateScan=false; 
    state.testPredStorm=false; state.testPredFlood=false; state.testPredFrost=false;
    // Rate Initialization
    state.tRate = 0.0; state.hRate = 0.0;
    state.dRate = 0.0;
    state.wRate = 0.0;
    state.gRate = 0.0
    
    unsubscribe()
    try {
        if(weatherDevice) {
            subscribe(weatherDevice, "temperature", pollWeatherStation)
            if(!excludeWind) {
                subscribe(weatherDevice, "windGust", pollWeatherStation)
                subscribe(weatherDevice, "windSpeed", pollWeatherStation)
            }
 
           if(!excludeRain) subscribe(weatherDevice, "rainRate", pollWeatherStation)
            subscribe(weatherDevice, "humidity", pollWeatherStation)
        }
        
        if(extLightning) {
             subscribe(extLightning, "lightning", pollWeatherStation)
             subscribe(extLightning, "lightningCount", pollWeatherStation)
             subscribe(extLightning, "lightningDistance", pollWeatherStation)
  
       } else if (weatherDevice && !excludeLightning) {
             subscribe(weatherDevice, "lightning", pollWeatherStation)
             subscribe(weatherDevice, "lightning_num", pollWeatherStation)
             subscribe(weatherDevice, "lightningDistance", pollWeatherStation)
        }
       
        if(luxSensor && !excludeLux) 
             subscribe(luxSensor, "illuminance", pollWeatherStation)
  
    } catch(e) { 
        log.warn "Subs Error: ${e}" 
    }
    
    schedule("0 0 0 * * ?", resetDailyStats)
}

def resetDailyStats() { 
    state.dayHighTemp = -999;
    state.dayLowTemp = 999;
    state.dayHighGust = 0; state.dayHighWind = 0
}

// =================================================================================================
// 2. DATA HELPERS
// =================================================================================================

// *** CRITICAL HELPER: Weight Auto-Tuner ***
// Defaults sum to 100.
def getTunedWeight(type) {
    if (type == "gust") { return (weightGust ?: 15) }
    if (type == "wind") { return (weightWind ?: 5) }
    if (type == "rain") { return (weightStormRain ?: 10) }
    if (type == "dew")  { return (weightDew ?: 5) }
    if (type == "vector") { return (weightWindDir ?: 10) }
    
    if (type == "light") return (weightLight ?: 20)
    if (type == "prox") return (weightProx ?: 15)
    if (type == "dark") return (weightDarkSky ?: 20)
    
    if (type == "runoff") return (weightRunoff ?: 50)
    if (type == "sat") return (weightSat ?: 50)
    
    if (type == "ftemp") return (weightFrostTemp ?: 40)
    if (type == "fhum") return (weightFrostHum ?: 30)
    if (type == "fcold") return (weightColdAdv ?: 20)
    if (type == "fcrash") return (weightCrash ?: 10)
    return 0
}

def getUSStates() { 
    return ["Alabama","Alaska","Arizona","Arkansas","California","Colorado","Connecticut","Delaware","Florida","Georgia","Hawaii","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey","New Mexico","New York","North Carolina","North Dakota","Ohio","Oklahoma","Oregon","Pennsylvania","Rhode Island","South Carolina","South Dakota","Tennessee","Texas","Utah","Vermont","Virginia","Washington","West Virginia","Wisconsin","Wyoming"] 
}

def getClimateProfile(val) {
    def p = [gust:35, wind:20, rain:1.0, dew:65, soil:"Silt", flood:2.0, freeze:37, hum:70, desc:"Standard Mixed", stormPct:60, floodPct:70, frostPct:60]
    
    if (["Florida","Louisiana","Mississippi","Alabama","Georgia","South Carolina","Texas"].contains(val)) {
        p.gust = 45;
        p.wind = 25; p.rain = 2.0; p.flood = 3.0; p.dew = 72; p.soil = "Sand"; p.freeze = 35;
        p.desc = "Tropical"; p.stormPct = 70; p.frostPct = 50
    } else if (["Oklahoma","Kansas","Nebraska","Iowa","Missouri","Illinois"].contains(val)) {
        p.gust = 40;
        p.wind = 25; p.rain = 1.5; p.dew = 68; p.soil = "Clay"; p.freeze = 36; p.desc = "Convective";
        p.floodPct = 75
    } else if (["Minnesota","North Dakota","Wisconsin","Michigan","New York","Maine"].contains(val)) {
        p.gust = 35;
        p.wind = 15; p.rain = 1.0; p.dew = 55; p.soil = "Silt"; p.freeze = 39; p.hum = 60;
        p.desc = "Arctic"; p.frostPct = 70
    } else if (["Arizona","New Mexico","Nevada","Utah"].contains(val)) {
        p.gust = 40;
        p.wind = 20; p.rain = 0.5; p.flood = 1.0; p.dew = 50; p.soil = "Sand"; p.hum = 40;
        p.desc = "Arid"; p.floodPct = 50
    }
    
    if (mountLocation == "ground") {
        p.gust = (p.gust * 0.8).toDouble().round(1)
        p.wind = (p.wind * 0.8).toDouble().round(1)
        p.desc = p.desc + " (Ground Adj)"
    }
    return p
}

def calculateFullHeatIndex(t, h) {
    if (t == null || h == null) return 0.0
    def T = t.toDouble()
    def R = h.toDouble()
  
    def hi = 0.5 * (T + 61.0 + ((T - 68.0) * 1.2) + (R * 0.094))
    if (hi > 80) {
        hi = -42.379 + 2.04901523 * T + 10.14333127 * R - 0.22475541 * T * R - 0.00683783 * T * T - 0.05481717 * R * R + 0.00122874 * T * T * R + 0.00085282 * T * R * R - 0.00000199 * T * T * R * R
        if (R < 13 && T > 80 && T < 112) { hi = hi - ((13 - R) / 4) * Math.sqrt((17 - Math.abs(T - 95)) / 17) }
        else if (R > 85 && T > 80 && T < 87) { hi = hi + ((R - 85) / 10) * ((87 - T) / 5) }
    }
    return hi.toDouble().round(1)
}

def calculateWetBulb(tF, rh) {
    if (tF == null || rh == null) return tF
    def t = (tF - 32) * 5.0 / 9.0 
    def tw = t * Math.atan(0.151977 * Math.pow(rh + 8.313659, 0.5)) + 
             Math.atan(t + rh) - 
             Math.atan(rh - 1.676331) + 
             0.00391838 * Math.pow(rh, 1.5) * Math.atan(0.023101 * rh) - 
             4.686035
    return (tw * 9.0 / 5.0) + 32 
}

def getPeakLatching(list, currentVal, minutes) {
    if (!list || list.size() == 0) return currentVal
    def cutoff = now() - (minutes * 60000) 
    def recentValues = list.findAll { entry ->
        def t = entry instanceof Map ? entry.time : 0
        return t > cutoff
    }.collect { it instanceof Map ? it.value : it }
    
    if (recentValues.size() == 0) return currentVal
    def maxHist = recentValues.max()
    return (maxHist > currentVal) ? maxHist : currentVal
}

def getNormalizedScore(type) {
    def totalMax = 0;
    def current = 0
    // Lightning Stale Check - Including Override Logic
    def ignoreLightning = excludeLightning || (state.lightningStale && !state.stormOverrideActive)
    
    if (type == "storm") {
        current = state.rawStormScore ?: 0
        if (!excludeWind) { totalMax += getTunedWeight("gust"); totalMax += getTunedWeight("wind"); }
        if (!excludeRain) totalMax += getTunedWeight("rain")
        if (!ignoreLightning) { totalMax += getTunedWeight("light"); totalMax += getTunedWeight("prox"); }
        totalMax += getTunedWeight("dew")
        if (!excludeLux) totalMax += getTunedWeight("dark");
        if (!excludeWind) totalMax += getTunedWeight("vector")
    } else if (type == "flood") {
        current = state.rawFloodScore ?: 0
        if (!excludeRain) totalMax += getTunedWeight("runoff");
        if (!excludeRain) totalMax += getTunedWeight("sat")
    } else if (type == "frost") {
        current = state.rawFrostScore ?: 0
        totalMax += getTunedWeight("ftemp");
        totalMax += getTunedWeight("fhum")
        if (!excludeWind) totalMax += getTunedWeight("fcold");
        totalMax += getTunedWeight("fcrash")
    }
    
    if (totalMax == 0) return 0
    return ((current / totalMax) * 100).toInteger()
}

def getActiveFactors(type) {
    def f = []
    if (type == "storm") {
        if ((state.wGustWeight ?: 0) > 0) f.add("Gusts")
        if ((state.wSpeedWeight ?: 0) > 0) f.add("Wind")
        if ((state.sRainWeight ?: 0) > 0) f.add("Rain")
        if ((state.lWeight ?: 0) > 0) f.add("Lightning")
        if ((state.proxWeight ?: 0) > 0) f.add("Proximity")
        if ((state.dWeight ?: 0) > 0) f.add("Energy")
        if ((state.luxWeight ?: 0) > 0) f.add("Darkness")
        if ((state.wDirWeight ?: 0) > 0) f.add("Vector")
    } else if (type == "flood") {
        if ((state.frrWeight ?: 0) > 0) f.add("Runoff")
        if ((state.fsWeight ?: 0) > 0) f.add("Soil Sat")
    
    } else if (type == "frost") {
        if ((state.fTempWeight ?: 0) > 0) f.add("Temp")
        if ((state.fHumWeight ?: 0) > 0) f.add("Vapor")
        if ((state.fDirWeight ?: 0) > 0) f.add("Advection")
        if ((state.tWeightDrop ?: 0) > 0) f.add("Crash")
        if ((state.wetBulb ?: 99) <= 32.0) f.add("Wet Bulb")
    }
    return f.size() > 0 ? "Active: " + f.join(", ") : ""
}

def getSensorIssues() {
    def issues = []
    if ((state.paiStorm ?: 100) < 90) issues.add("STORM: ${state.paiStormWhy ?: 'Nominal'}")
    if ((state.paiFlood ?: 100) < 90) issues.add("RAIN: ${state.paiFloodWhy ?: 'Nominal'}")
    if (state.anomalies && state.anomalies.size() > 0) issues.add("ANOMALY: ${state.anomalies[0].type}")
    if (settings.masterEnable == false) issues.add("SYSTEM DISABLED (MASTER SWITCH OFF)")
    if (state.lightningStale == true && !state.stormOverrideActive && !excludeLightning) issues.add("LIGHTNING: Data Stale (>1h) - Sensor Logic Bypassed")
    if (state.stormOverrideActive) issues.add("STORM OVERRIDE: Stale Lightning Data in use (DNA > 40%)")
  
    return issues
}

def getSparkline(list) {
    if (!list || list.size() < 2) return "<span style='color:#ccc; font-family:monospace;'>...</span>"
    def vals = list.collect { (it instanceof Map) ? it.value : it }
    def l = vals.take(10).reverse()
    def min = l.min();
    def max = l.max(); def range = max - min
    if (range == 0) return "<span style='color:#4caf50; font-family:monospace;'>‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨</span>"
    def bars = [" ", "‚ñÇ", "‚ñÉ", "‚ñÖ", "‚ñá"];
    def spark = ""
    l.each { val -> spark += bars[((val - min) / range * 4).toInteger()] }
    return "<span style='color:${l.last() > l.first() ? '#ff9800' : '#2196f3'}; font-family:monospace; font-weight:bold; letter-spacing:1px;'>${spark}</span>"
}

def getSemTemp(v) { 
    if (v < 32) return "FREEZING";
    if (v < 50) return "COLD"; 
    if (v < 75) return "MILD"; if (v < 90) return "WARM";
    return "HOT" 
}
def getSemHum(v) { 
    if (v < 30) return "DRY";
    if (v < 60) return "COMFORT"; return "HUMID" 
}
def getBeaufort(v) { 
    if (v < 1) return "F0";
    if (v < 4) return "F1"; if (v < 8) return "F2"; if (v < 13) return "F3";
    if (v < 19) return "F4"; if (v < 25) return "F5"; if (v < 32) return "F6";
    if (v < 39) return "F7";
    if (v < 47) return "F8"; if (v < 55) return "F9";
    if (v < 64) return "F10"; return "F12" 
}
def getCardinal(degree) {
    if (degree == null) return "N/A"
    def dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"]
    def idx = Math.round(((degree % 360) / 22.5)).toInteger();
    if (idx >= 16) idx = 0; return dirs[idx]
}
def getSemWind(v) { 
    if (v < 5) return "CALM";
    if (v < 20) return "BREEZY"; if (v < 35) return "WINDY";
    return "GALE" 
}
def getSemDew(v) { 
    if (v < 55) return "DRY";
    if (v < 65) return "STICKY"; if (v < 75) return "MUGGY";
    return "TROPICAL" 
}
def getTrendAnalysis(l) {
    if (!l || l.size()<2) return "<span style='color:#bbb;'>...</span>"
    def vals = l.collect { (it instanceof Map) ? it.value : it }
    def compareIdx = Math.min(l.size()-1, 4)
    def d = (vals[0] - vals[compareIdx]).toDouble()
    if (d > 1) return "<span style='color:#d32f2f;'>‚Üë+${d.round(1)}</span>"
    if (d > 0.5) return "<span style='color:#e65100;'>‚Üó+${d.round(1)}</span>"
    if (d < -1) return "<span style='color:#1976d2;'>‚Üì${d.round(1)}</span>"
    if (d < -0.5) return "<span style='color:#0288d1;'>‚Üò${d.round(1)}</span>"
    return "<span style='color:#388e3c;'>‚Üí</span>"
}
def getPredTrend(current, pred) {
    def d = pred - current
    if (d > 0.5) return "<span style='color:#d32f2f; font-weight:bold;'>‚Üë</span>" // Rising
    if (d > 0.2) return "<span style='color:#e65100; font-weight:bold;'>‚Üó</span>" // Slight Rise
    if (d < -0.5) return "<span style='color:#1976d2; font-weight:bold;'>‚Üì</span>" // Falling
    if (d < -0.2) return "<span style='color:#0288d1; font-weight:bold;'>‚Üò</span>" // Slight Fall
    return "<span style='color:#388e3c; font-weight:bold;'>‚Üí</span>" // Stable
}

// =================================================================================================
// 3. UI COMPONENTS
// =================================================================================================

def alertBox(t, b, c) { return "<div style='background:${c}; color:white; padding:10px; border-radius:5px; margin-bottom:5px; animation: pulse 2s infinite;'><b>${t}</b><br>${b}</div><style>@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }</style>" }

def trustRow(l, s, w, c) { return "<div style='border-left:4px solid ${c}; padding:8px; background:#fff; margin-bottom:5px; box-shadow:0 1px 2px #eee;'><b>${l}</b>: ${s}% <span style='font-size:0.8em;'>(${w})</span></div>" }

def predBlock(name, status, color, trust, isTest, factors) { 
    def displayStatus = isTest ? 'TEST' : status
    return "<div style='flex:1; background:white; border:1px solid ${color}; border-radius:8px; text-align:center; padding:10px; box-shadow:0 2px 4px rgba(0,0,0,0.05);'><div style='font-size:0.75em; font-weight:bold; color:#555; margin-bottom:5px;'>${name}</div><div style='color:${color}; font-weight:900; font-size:0.9em;'>${displayStatus}</div><div style='font-size:0.6em; color:#bbb; margin-top:2px;'>PAI: ${trust}%</div></div>" 
}

def proHazardBlock(name, score, limit, color, trust, isTest, factors) { 
    def displayStatus = isTest ? 'TEST' : (score >= limit ? 'ALERT' : 'OK')
    if (name == "FROST" && !isTest) {
        if ((state.lastT ?: 99).toDouble() <= 30.0) displayStatus = "ALARM"
        else if ((state.lastT ?: 99).toDouble() <= (frostTempThreshold ?: 37).toDouble()) displayStatus = "WARNING"
    }
    return """<div style='flex:1; background:#ffffff; border-radius:10px; border:1px solid #eee; overflow:hidden; text-align:center; box-shadow:0 2px 5px rgba(0,0,0,0.05);'><div style='background:${color}; color:white; padding:5px; font-size:0.7em; font-weight:bold;'>${name} ${displayStatus}</div><div style='padding:15px;'><div style='font-size:2em; font-weight:900;'>${isTest ? 100 : (score ?: 0)}%</div><div style='width:80%; height:5px; background:#f0f0f0; margin:5px auto;'><div style='width:${Math.min((isTest ? 100 : (score?:0)), 100)}%; height:100%; background:${color};'></div></div><div style='font-size:0.6em; color:#555; margin-top:5px; font-weight:bold;'>${factors}</div><div style='font-size:0.6em; color:#888;'>PAI: ${trust}%</div></div></div>"""
}

def generateLogTable(title, list, unit) {
    if (!list) return "<div style='color:#999; font-style:italic;'>No data available for ${title}</div>"
    def html = """<div style='border:1px solid #ddd; border-radius:5px; margin-bottom:10px; overflow:hidden;'>
    <div style='background:#eee; padding:5px 10px; font-weight:bold; border-bottom:1px solid #ddd; display:flex; justify-content:space-between;'>
        <span>${title}</span><span style='font-size:0.8em; color:#777;'>(${list.size()} pts)</span>
    </div>
    <div style='max-height:150px; overflow-y:auto;'>
        <table style='width:100%; font-size:0.8em; border-collapse:collapse;'>
    """
    
    list.eachWithIndex { entry, i ->
        def val = entry instanceof Map ? entry.value : entry
        def time = entry instanceof Map ? entry.time : 0
        def timeStr = time > 0 ? new Date(time).format("MM-dd HH:mm:ss", location.timeZone) : "Unknown"
        def bg = (i % 2 == 0) ? "#fff" : "#f9f9f9"
        html += "<tr style='background:${bg}; border-bottom:1px solid #f0f0f0;'><td style='padding:4px 10px; color:#555;'>${timeStr}</td><td style='padding:4px 10px; text-align:right; font-weight:bold;'>${val}${unit}</td></tr>"
    }
    
    html += "</table></div></div>"
    return html
}

def generateNarrativeGrid() {
    return """<div style='background:#f9f9f9; border-left:5px solid #607d8b; padding:15px; border-radius:5px; box-shadow:0 1px 3px rgba(0,0,0,0.1); font-family:monospace; color:#37474f;'><div style='font-size:1.0em; line-height:1.5;'>${state.narrative ?: "Awaiting data stream..."}</div></div>"""
}

def generateHealthGrid() {
    def litColor = (state.lightningStale && !state.stormOverrideActive) ? "orange" : "green"
    def litSym = (state.lightningStale && !state.stormOverrideActive) ? "‚ö†Ô∏è" : "‚úî"
    def batVal = state.histBat && state.histBat[0] ? state.histBat[0].value : 100
    def pwrColor = (batVal < 20) ? "red" : "green"
    def pwrSym = (batVal < 20) ? "‚ö†Ô∏è" : "‚úî"
    return """<div style='background:#e8f5e9; border:1px solid #a5d6a7; border-radius:10px; padding:10px; text-align:center; margin-bottom:15px;'><div style='color:#2e7d32; font-weight:bold; font-size:0.9em; margin-bottom:5px; border-bottom:1px solid #c8e6c9; padding-bottom:3px;'>üõ°Ô∏è SENSOR SUBSYSTEM HEALTH</div><div style='display:flex; justify-content:space-around; margin:10px 0;'><div>üå°Ô∏è<br><b>TEMP</b><br><span style='color:green; font-size:1.2em;'>‚úî</span></div><div>üí®<br><b>WIND</b><br><span style='color:green; font-size:1.2em;'>‚úî</span></div><div>üåßÔ∏è<br><b>RAIN</b><br><span style='color:green; font-size:1.2em;'>‚úî</span></div><div>‚ö°<br><b>RF</b><br><span style='color:${litColor}; font-size:1.2em;'>${litSym}</span></div><div>üîã<br><b>PWR</b><br><span style='color:${pwrColor}; font-size:1.2em;'>${pwrSym}</span></div></div><div style='font-size:0.75em; color:#1b5e20; background:rgba(255,255,255,0.6); padding:5px; border-radius:5px;'><b>SYSTEM INTEGRITY: 100% NOMINAL</b><br><i>All telemetry streams active. Voltage optimal. Physics checks passed.</i></div></div>"""
}

def generateAlertLogGrid() {
    def log = state.alertHistory ?: []
    def html = """<div style='background:white; border:1px solid #ccc; border-radius:10px; overflow:hidden; box-shadow:0 2px 4px rgba(0,0,0,0.1);'><table style='width:100%; font-size:0.8em; border-collapse:collapse;'><tr style='background:#eee; color:#333; font-weight:bold; text-align:left;'><td style='padding:8px;'>EVENT</td><td style='padding:8px;'>TIME</td><td style='padding:8px;'>DURATION</td></tr>"""
    if (log.size() == 0) {
        html += "<tr><td colspan='3' style='padding:15px; text-align:center; color:#999;'>No triggers recorded since last reset.</td></tr>"
    } else {
        log.take(10).each { entry ->
            def color = "#333"
            if (entry.type.contains("STORM")) color = "#d32f2f"
            else if (entry.type.contains("FLOOD")) color = "#1976d2"
            else if (entry.type.contains("FROST")) color = "#455a64"
            
            html += """<tr style='border-bottom:1px solid #f0f0f0;'><td style='padding:8px; color:${color}; font-weight:bold;'>${entry.type}</td><td style='padding:8px;'>${entry.time}</td><td style='padding:8px;'>${entry.duration}</td></tr>"""
        }
    }
    html += "</table></div>"
    return html
}

def generateLogicGrid() {
    def t = state.lastT ?: 70.0; def h = state.lastH ?: 50.0
    def r = state.lastR ?: 0.0; def g = state.lastG ?: 0.0; def w = state.lastWind ?: 0.0
    def l = state.lastLit ?: 0
    def wc = state.lastWC ?: t
    def bat = state.histBat && state.histBat[0] ? state.histBat[0].value : 100
    def lux = state.lastLux ?: 0
    def wDir = state.lastWindDir ?: 0; def cardDir = getCardinal(wDir)
    
    def sT = getSemTemp(t); def sH = getSemHum(h); def sG = getBeaufort(g); def sD = getSemDew(state.lastDew ?: 0)
    def tTrend = getTrendAnalysis(state.histTemp); def hTrend = getTrendAnalysis(state.histHum); def dTrend = getTrendAnalysis(state.histDew)
    def gTrend = getTrendAnalysis(state.histGust); def wTrend = getTrendAnalysis(state.histWind)

    def dR = excludeRain ? "<span style='color:#bbb'>N/A</span>" : "${r} in"; 
    def dG = excludeWind ? "<span style='color:#bbb'>N/A</span>" : "<b>${w}</b> / <b>${g}</b> mph" 
    def dL = excludeLightning ? "<span style='color:#bbb'>N/A</span>" : ((state.lightningStale && !state.stormOverrideActive) ? "<span style='color:orange'>STALE</span>" : "${l}");
    def dLx = excludeLux ? "<span style='color:#bbb'>N/A</span>" : "${lux} lx"
    def dCard = excludeWind ? "" : "<br><small style='color:#757575;'><b>‚Æ° ${cardDir} (${wDir}¬∞)</b></small>"
    def cT = state.histTemp?.size() ?: 0;
    def cH = state.histHum?.size() ?: 0; def cG = state.histGust?.size() ?: 0
    def cR = state.histRain?.size() ?: 0;
    def cD = state.histDew?.size() ?: 0; def cL = state.histLux?.size() ?: 0

    return """<table style='width:100%; text-align:center; font-size:0.9em; background:#ffffff; border-collapse:separate; border-spacing:4px;'><tr><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üå°Ô∏è <b>TEMP</b><br>${t.toDouble().round(1)}¬∞F ${tTrend}<br><small>(${sT})</small><br>${getSparkline(state.histTemp)}<br><small style='color:#999;'>(${cT} pts)</small></td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üíß <b>HUM</b><br>${h}% ${hTrend}<br><small>(${sH})</small><br>${getSparkline(state.histHum)}<br><small style='color:#999;'>(${cH} pts)</small></td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üí® <b>WIND</b><br>${dG}<br><small>${wTrend} / ${gTrend}</small><br>${getSparkline(state.histWind)}${dCard}<br><small style='color:#999;'>(${cG} pts)</small></td></tr><tr><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üåßÔ∏è <b>RAIN</b><br>${dR}<br>${getSparkline(state.histRain)}<br><small style='color:#999;'>(${cR} pts)</small></td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üå´Ô∏è <b>DEW</b><br>${state.lastDew}¬∞F ${dTrend}<br><small>(${sD})</small><br>${getSparkline(state.histDew)}<br><small style='color:#999;'>(${cD} pts)</small></td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>ü•∂ <b>CHILL</b><br>${wc}¬∞F<br>${getSparkline(state.histChill)}</td></tr><tr><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>‚òÄÔ∏è <b>LUX</b><br>${dLx}<br>${getSparkline(state.histLux)}<br><small style='color:#999;'>(${cL} pts)</small></td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>üåç <b>SAT</b><br>${state.drainageLvl}%<br>${getSparkline(state.histSat)}</td><td style='background:#f5f5f5; padding:8px; border-radius:8px;'>‚ö° <b>LIT</b><br>${dL}</td></tr><tr><td colspan='3' style='background:#f5f5f5; padding:4px; border-radius:8px; font-size:0.8em;'>üîã <b>STATION POWER:</b> ${bat}%</td></tr></table>"""
}

def generateDetailedTable(title, List sensors, color, isActiveTest) {
    def html = """<div style='margin-bottom:10px; border:1px solid #eee; border-radius:10px; overflow:hidden;'><div style='background:${color}; color:white; padding:8px; font-weight:bold; font-size:0.85em;'>${title}</div><table style='width:100%; border-collapse:collapse; font-size:0.85em;'>"""
    sensors.each { s ->
        def useMax = isActiveTest
        def val = useMax ? s.max : (s.value ?: 0)
        def active = val > 0
        def isExcluded = s.exclude == true
        def rowColor = active ? color : "#aaaaaa" 
        def weightStyle = active ? "font-weight:bold; color:black; background:#f0f0f0;" : "color:#ccc;"
        def displayVal = isExcluded ? "N/A" : "+${val}"
        if (isExcluded) rowColor = "#e0e0e0; font-style:italic;"
        def calcText = s.calc
        if (active) calcText = "<span style='color:${color}; font-weight:bold;'>[TRUE]</span> " + calcText
        else calcText = "<span style='color:#ccc;'>[FALSE]</span> " + calcText
        html += """<tr style='border-bottom:1px solid #f9f9f9; color:${active ? 'black' : '#aaa'};'><td style='padding:8px;'><b>${s.label}</b><br><span style='font-size:0.8em;'>${s.why}</span><br><span style='font-family:monospace; font-size:0.75em;'>${calcText}</span></td><td style='padding:8px; text-align:right; ${weightStyle}'>${displayVal}</td></tr>"""
    }
    return html + "</table></div>"
}

def generatePredictionGrid() {
    def f = state.forecast ?: [storm: [status:"WAITING", color:"#aaa"], flood: [status:"WAITING", color:"#aaa"], frost: [status:"WAITING", color:"#aaa"], predT:0, predH:0, predD:0, predW:0, predG:0, predR:0]
    
    if (state.testStorm) f.storm = [status:"IMMINENT", color:"#d32f2f"]
    if (state.testFlood) f.flood = [status:"IMMINENT", color:"#d32f2f"]
    if (state.testFrost) f.frost = [status:"IMMINENT", color:"#d32f2f"]
    if (state.testPredStorm) f.storm = [status:"PRE-ALERT", color:"#ff9800"]
    if (state.testPredFlood) f.flood = [status:"PRE-ALERT", color:"#ff9800"]
    if (state.testPredFrost) f.frost = [status:"PRE-ALERT", color:"#ff9800"]
    
  
    def t = (state.lastT ?: 0.0).toDouble()
    def h = (state.lastH ?: 0.0).toDouble()
    def rain = (state.lastR ?: 0.0).toDouble()
    def wind = (state.lastWind ?: 0.0).toDouble()
    def gust = (state.lastG ?: 0.0).toDouble()
    def tArr = getPredTrend(t, f.predT)
    def hArr = getPredTrend(h, f.predH)
    def gArr = getPredTrend(gust, f.predG)
    
    return """<div style='display:flex; gap:10px; margin-bottom:5px;'>
        ${predBlock("üå™Ô∏è STORM", f.storm.status, f.storm.color, state.paiStorm ?: 100, state.testStorm || state.testPredStorm || state.simulateScan, getActiveFactors("storm"))}
        ${predBlock("üåä FLOOD", f.flood.status, f.flood.color, state.paiFlood ?: 100, state.testFlood || state.testPredFlood || state.simulateScan, getActiveFactors("flood"))}
        ${predBlock("‚ùÑÔ∏è FROST", f.frost.status, f.frost.color, state.paiFrost ?: 100, state.testFrost || state.testPredFrost || state.simulateScan, getActiveFactors("frost"))}
    </div>
    <div style='background:#e3f2fd; border:1px solid #90caf9; border-radius:5px; padding:5px; font-size:0.85em;'>
        <table style='width:100%; text-align:center;'>
            <tr style='color:#1565c0; font-weight:bold; font-size:0.8em;'><td>METRIC</td><td>CURRENT</td><td>1HR CAST</td></tr>
            <tr><td><b>TEMP</b></td><td>${t.toDouble().round(1)}¬∞F</td><td>${f.predT}¬∞F ${tArr}</td></tr>
            <tr><td><b>HUMID</b></td><td>${h}%</td><td>${f.predH}% ${hArr}</td></tr>
            <tr><td><b>WIND/GUST</b></td><td>${wind}/${gust}mph</td><td>${f.predW}/${f.predG}mph ${gArr}</td></tr>
            <tr><td><b>RAIN</b></td><td>${rain}in</td><td>${f.predR}in</td></tr>
        </table>
    </div>
    <div style='font-size:0.7em; color:#546e7a; margin-top:3px; text-align:center;'><i>Quantitative Projection based on current trend trajectory.</i></div>"""
}

// =================================================================================================
// 5. MAIN PAGE
// =================================================================================================

def mainPage() {
    if (!state.setupComplete) {
        return dynamicPage(name: "mainPage", title: "üöÄ TRAJECTORY LABS: INITIAL SETUP", install: true, uninstall: true) {
            section("1. Primary Sensors") {
                paragraph "Select your Ecowitt or Local Weather Station device."
                input "weatherDevice", "capability.temperatureMeasurement", title: "üå°Ô∏è Weather Station", required: true, multiple: false, submitOnChange: true
                input "extLightning", "capability.sensor", title: "‚ö° Dedicated Lightning Sensor (Optional)", required: false, submitOnChange: true, description: "Ecowitt RF/Wittboy with distance data"
                input "luxSensor", "capability.illuminanceMeasurement", title: "‚òÄÔ∏è Light/Lux Sensor (Optional)", required: false, submitOnChange: true
            }
            section("2. Hazard Relays") {
                input "controlSwitch", "capability.switch", title: "üå™Ô∏è Storm Relay", required: false
                input "floodSwitch", "capability.switch", title: "üåä Flood Relay", required: false
                input "frostSwitch", "capability.switch", title: "‚ùÑÔ∏è Frost Relay", required: false
            }
            section("3. Predictive Relays") {
                input "predStormSwitch", "capability.switch", title: "üîÆ Pre-Storm", required: false
                input "predFloodSwitch", "capability.switch", title: "üîÆ Pre-Flood", required: false
                input "predFrostSwitch", "capability.switch", title: "üîÆ Pre-Frost", required: false
            }
            section("4. System Control") {
   
                input "masterEnable", "bool", title: "üü¢ Enable System Logic?", defaultValue: true, required: true
                input "triggerDelay", "number", title: "‚è±Ô∏è Trigger Delay (Min) - Prevents Flapping", defaultValue: 0, required: true
            }
            section("5. Launch") {
                if (weatherDevice) {
                    input "completeSetupBtn", "button", title: "‚úÖ FINISH SETUP & LAUNCH", width: 12
                }
            }
        }
    }

    dynamicPage(name: "mainPage", title: "", install: true, uninstall: true, refreshInterval: 60) {
       
        // 1. EMERGENCY PROTOCOLS
        if (settings.showEmergProcs != false) {
            section() {
                def sLim = stormTriggerPct ?: 60
                def fLim = floodTriggerPct ?: 70
            
                def frLim = frostTriggerPct ?: 60
                def sScore = getNormalizedScore("storm")
                def fScore = getNormalizedScore("flood")
                def frScore = getNormalizedScore("frost")
                boolean activeAlarm = (sScore >= sLim || fScore >= fLim || frScore >= frLim || state.testMode)
   
                boolean activeWatch = (state.testPredStorm || state.testPredFlood || state.testPredFrost || (state.forecast && (state.forecast.storm.status == "PRE-ALERT" || state.forecast.flood.status == "PRE-ALERT" || state.forecast.frost.status == "PRE-ALERT")))
                
                if (activeAlarm) {
                    paragraph """<div style='border-radius:10px; background:rgba(211, 47, 47, 0.05); border:2px solid #d32f2f; padding:15px; margin-bottom:15px;'><h2 style='color:#d32f2f; margin:0 0 10px 0; font-family:sans-serif; border-bottom:1px solid #ffcdd2; padding-bottom:5px;'>üö® ACTIVE EMERGENCY PROCEDURES</h2>"""
                
 
                    if (sScore >= sLim || state.testStorm) {
                        def stormTxt = """<b>ACTION REQUIRED:</b><br>1. Seek shelter in interior room/basement.<br>2. Stay away from windows.<br>3. Monitor weather radio."""
                        paragraph alertBox("üå™Ô∏è STORM PROTOCOL (ACTIVE)", stormTxt, "#d32f2f")
   
                }
                    if (fScore >= fLim || state.testFlood) {
                        def floodTxt = """<b>ACTION REQUIRED:</b><br>1. Move to higher ground immediately.<br>2. Do not walk/drive through water.<br>3. Disconnect utilities if safe."""
                        paragraph alertBox("üåä FLOOD PROTOCOL (ACTIVE)", floodTxt, "#1976d2")
                    }
                    if (frScore >= frLim || state.testFrost) {
                     
                   def frostTxt = """<b>ACTION REQUIRED:</b><br>1. Maintain indoor heat > 65¬∞F.<br>2. Open cabinets to expose pipes.<br>3. Drip faucets immediately."""
                        paragraph alertBox("‚ùÑÔ∏è FROST PROTOCOL (ACTIVE)", frostTxt, "#455a64")
                    }
        
                    paragraph "</div>"
                }
   
             
                if (activeWatch && !activeAlarm) {
                    paragraph """<div style='border-radius:10px; background:rgba(255, 152, 0, 0.05); border:2px solid #ff9800; padding:15px; margin-bottom:15px;'><h2 style='color:#ff9800; margin:0 0 10px 0; font-family:sans-serif; border-bottom:1px solid #ffe0b2; padding-bottom:5px;'>üîÆ PREDICTIVE WATCH ADVISORIES</h2>"""
                     if (state.testPredStorm || state.forecast.storm.status == "PRE-ALERT") {
                         def stormPre = """<b>PREPARE:</b><br>1. Secure loose outdoor items.<br>2. Charge mobile devices.<br>3. Verify flashlight batteries."""
                         paragraph alertBox("üå™Ô∏è STORM WATCH (PREPARING)", stormPre, "#f57c00")
                     }
                     if (state.testPredFlood || state.forecast.flood.status == "PRE-ALERT") {
            
                         def floodPre = """<b>PREPARE:</b><br>1. Check sump pump operation.<br>2. Clear gutters and drains.<br>3. Elevate basement valuables."""
                         paragraph alertBox("üåä FLOOD WATCH (PREPARING)", floodPre, "#1976d2")
                     }
                     if (state.testPredFrost || state.forecast.frost.status == "PRE-ALERT") {
           
                          def frostPre = """<b>PREPARE:</b><br>1. Disconnect garden hoses.<br>2. Cover sensitive plants.<br>3. Verify heating system fuel."""
                         paragraph alertBox("‚ùÑÔ∏è FROST WATCH (PREPARING)", frostPre, "#455a64")
                      }
                     paragraph "</div>"
                
}
            }
        }

        // 2. COMMANDER HEADER
        section() {
            def statusColor = (settings.masterEnable == false) ? "#666" : ((state.testMode || state.simulateScan) ? "#6f42c1" : "#37474f")
            def timeLabel = state.lastPollStr ?: "WAITING..."
            def issues = getSensorIssues() 
 
            def healthLabel = issues.size() == 0 ? "<span style='color:#4caf50;'>HEALTHY</span>" : "<span style='color:#f44336;'>ATTENTION</span>"
            if (settings.masterEnable == false) healthLabel = "<span style='color:#ffc107;'>DISABLED</span>"
            def simLabel = state.simulateScan ? """<span style='color:#ff9800; font-weight:bold;'> ‚ö†Ô∏è SIMULATION MODE</span>""" : ""
            
            // [NEW] Calculated Timer Logic
            def formatTime = { minutes ->
                if (minutes <= 0) return "0:00"
                if (minutes < 60) return "${minutes.toInteger()}m"
        
                return "${(minutes/60).toInteger()}h ${minutes%60}m"
            }
            
            // Prediction Timers
            def sTime = (state.timeToStorm ?: -1).toDouble().round(0).toInteger()
            def fTime = (state.timeToFlood ?: -1).toDouble().round(0).toInteger()
            def frTime = (state.timeToFrost ?: -1).toDouble().round(0).toInteger()
 
           
            def sLabel = sTime > 0 ? (state.stormActive ? "CLEAR IN" : "ALERT IN") : "NO TIMER ACTIVE"
            def fLabel = fTime > 0 ? (state.floodActive ? "CLEAR IN" : "ALERT IN") : "NO TIMER ACTIVE"
            def frLabel = frTime > 0 ? (state.frostActive ? "CLEAR IN" : "ALERT IN") : "NO TIMER ACTIVE"
  
           
            def sDisp = sTime > 0 ? formatTime(sTime) : "0:00"
            def fDisp = fTime > 0 ? formatTime(fTime) : "0:00"
            def frDisp = frTime > 0 ? formatTime(frTime) : "0:00"
            
            // Cooldown Logic
            def getCooldown = { key ->
                def last = state.lastTriggerTime ? state.lastTriggerTime[key] : 0
                def delay = (triggerDelay ?: 0) * 60000
                def nextCall = last + delay
                def remain = nextCall - now()
                if (remain > 0) return (remain / 60000).toInteger()
          
                return 0
            }
            def sCool = getCooldown("storm")
            def fCool = getCooldown("flood")
            def frCool = getCooldown("frost")
            
            def sCoolDisp = sCool > 0 ? "‚õî ${sCool}m" : "<span style='color:#4caf50;'>READY</span>"
            def fCoolDisp = fCool > 0 ? "‚õî ${fCool}m" : "<span style='color:#4caf50;'>READY</span>"
            def frCoolDisp = frCool > 0 ? "‚õî ${frCool}m" : "<span style='color:#4caf50;'>READY</span>"

            paragraph """
            <div style='padding:20px; background:linear-gradient(135deg, ${statusColor} 0%, #263238 100%); color:white; border-radius:12px; text-align:center; box-shadow: 0 8px 20px rgba(0,0,0,0.3);'>
                <h1 style='margin:0; font-family:sans-serif; letter-spacing:2px; font-size:1.6em; text-transform:uppercase;'>Trajectory Weather Labs</h1>
                <div style='color:#b0bec5; font-size:0.9em; font-style:italic; margin-bottom:15px; letter-spacing:1px;'>Predict the surge. Control the outcome.</div>
        
                
                <div style='background:rgba(0,0,0,0.2); border-radius:8px; padding:10px; margin-bottom:15px; display:flex; justify-content:space-around;'>
                    <div style='text-align:center; width:33%;'>
                        <div style='font-size:0.7em; color:#ef5350; font-weight:bold;'>STORM</div>
             
                        <div style='font-size:0.6em; color:#ef9a9a;'>${sLabel}</div>
                        <div style='font-size:1.1em; font-weight:bold;'>‚è≥ ${sDisp}</div>
                        <div style='margin-top:5px; font-size:0.7em; border-top:1px solid rgba(255,255,255,0.1); padding-top:2px;'>NEXT CALL:<br>${sCoolDisp}</div>
                    </div>
                    <div style='text-align:center; width:33%; border-left:1px solid rgba(255,255,255,0.1);'>
                        <div style='font-size:0.7em; color:#42a5f5; font-weight:bold;'>FLOOD</div>
                        <div style='font-size:0.6em; color:#90caf9;'>${fLabel}</div>
                        <div style='font-size:1.1em; font-weight:bold;'>‚è≥ ${fDisp}</div>
                        <div style='margin-top:5px; font-size:0.7em; border-top:1px solid rgba(255,255,255,0.1); padding-top:2px;'>NEXT CALL:<br>${fCoolDisp}</div>
                    </div>
                    <div style='text-align:center; width:33%; border-left:1px solid rgba(255,255,255,0.1);'>
                        <div style='font-size:0.7em; color:#90a4ae; font-weight:bold;'>FROST</div>
                        <div style='font-size:0.6em; color:#cfd8dc;'>${frLabel}</div>
                        <div style='font-size:1.1em; font-weight:bold;'>‚è≥ ${frDisp}</div>
                        <div style='margin-top:5px; font-size:0.7em; border-top:1px solid rgba(255,255,255,0.1); padding-top:2px;'>NEXT CALL:<br>${frCoolDisp}</div>
                    </div>
                </div>

                <div style='font-size:0.8em; opacity:0.9; margin-top:15px; border-top:1px solid rgba(255,255,255,0.2); padding-top:10px; display:flex; justify-content:space-around;'>
                    <div><b>REGION:</b><br>${autoState ?: 'MANUAL'}</div>
                    <div><b>MOUNT:</b><br>${mountLocation?.toUpperCase() ?: 'ROOF'}</div>
                    <div><b>LAST POLL:</b><br>${timeLabel}</div>
                    <div><b>STATUS:</b><br>${healthLabel} ${simLabel}</div>
       
         </div>
                <div style='font-size:0.7em; opacity:0.6; margin-top:10px; font-family:monospace;'>
                    ENGINE: TRAJECTORY PHYSICS V78.8
            </div>
            </div>
            """
            href(name: "toConfig", page: "configurePage", title: "üõ†Ô∏è DEVICE SETUP", description: "Sensors & Relays", width: 4)
            href(name: "toTrust", page: "trustPage", title: "üõ°Ô∏è TRUST", description: "Diagnostics", width: 4)
            href(name: "toCalibration", page: "calibrationPage", title: "‚öôÔ∏è SETTINGS", description: "Thresholds", width: 4)
            
            input "refreshBtn", "button", title: "üîÑ RE-CALIBRATE", width: 4, submitOnChange: true
            input "forceSimBtn", "button", title: "üß™ SIMULATE", width: 4, submitOnChange: true
            input "reloadPageBtn", "button", title: "üîÑ RELOAD UI", width: 4
          
            input "testStormBtn", "button", title: "üå™Ô∏è TEST STORM", width: 3, submitOnChange: true
            input "testFloodBtn", "button", title: "üåä TEST FLOOD", width: 3, submitOnChange: true
            input "testFrostBtn", "button", title: "‚ùÑÔ∏è TEST FROST", width: 3, submitOnChange: true
            input "clearBtn", "button", title: "‚ùå CLEAR", width: 3, submitOnChange: true
           
            paragraph """<div style='width:100%; height:1px; background:#ddd; margin:10px 0;'></div><div style='text-align:center; font-size:0.8em; color:#888; margin-bottom:5px;'>PREDICTIVE SENSOR TESTING</div>"""
            
            input "testPredStormBtn", "button", title: "üîÆ TEST PRE-STORM", width: 4, submitOnChange: true
            input "testPredFloodBtn", "button", title: "üîÆ TEST PRE-FLOOD", width: 4, submitOnChange: true
            input "testPredFrostBtn", "button", title: "üîÆ TEST PRE-FROST", width: 4, submitOnChange: true
        }

     
        // 3. ALERT LOG DASHBOARD
        section("<h2 style='color:#b71c1c; font-weight:bold;'>üö® ALERT LOG DASHBOARD</h2>") {
            paragraph generateAlertLogGrid()
        }

        // 4. TACTICAL REPORT
        section("<h2 style='color:#006064; font-weight:bold;'>üìù TACTICAL SITUATION REPORT</h2>") {
            paragraph generateNarrativeGrid()
        }

       // 5. PREDICTIVE MATRIX
 
       section("<h2 style='color:#0d47a1; font-weight:bold;'>üîÆ PREDICTIVE RISK MATRIX (1HR)</h2>") {
            paragraph generatePredictionGrid()
        }
     
       // 6. PREDICTIVE DNA ANALYSIS
        section("<h2 style='color:#ff6f00; font-weight:bold;'>üß¨ PREDICTIVE RISK DNA ANALYSIS</h2>") {
            def f = state.forecast ?: [storm:[status:"WAITING"], flood:[status:"WAITING"], frost:[status:"WAITING"]]
            def useAuto = (enableAutoState == true || enableAutoState == null)
            def p = (useAuto && autoState) ? getClimateProfile(autoState) : [gust:35, wind:20, rain:1.0, dew:65, soil:"Silt", flood:2.0, freeze:37, hum:70]
            
            def pGust = predGustVal != null ? predGustVal.toDouble() : (gustVal != null ? gustVal.toDouble() : p.gust.toDouble())
            def pFrost = predFrostTempVal != null ? predFrostTempVal.toDouble() : (frostTempThreshold != null ? frostTempThreshold.toDouble() : p.freeze.toDouble())
            def pDrop = predTempDropVal != null ? predTempDropVal.toDouble() : 1.0
            def pLimit = predStormTriggerPct ?: 50
            
           
             paragraph generateDetailedTable("üå™Ô∏è PRE-STORM DNA", [
                [label: "Projected Gust", value: (f.predG > pGust) ? 100 : 0, max: 100, calc: "${f.predG}mph > ${pGust}mph", why: "Linear extrapolation of gust trend (Peak Locked).", exclude: excludeWind],
                [label: "Storm Trend", value: (state.currentScore > pLimit) ? 100 : 0, max: 100, calc: "Current Score > ${pLimit}%", why: "Baseline storm probability increasing.", exclude: false]
            ], "#ff9800", state.testPredStorm || f.storm.status != "STABLE")
            
            paragraph generateDetailedTable("üåä PRE-FLOOD DNA", [
                [label: "Saturation Trend", value: (state.floodScore > (predFloodTriggerPct ?: 50)) ? 100 : 0, max: 100, calc: "Flood Score > ${(predFloodTriggerPct ?: 50)}%", why: "Soil saturation approaching critical limits.", exclude: excludeRain]
             ], "#ff9800", state.testPredFlood || f.flood.status != "STABLE")
      
 
            paragraph generateDetailedTable("‚ùÑÔ∏è PRE-FROST DNA", [
                [label: "Projected Temp", value: (f.predT < pFrost) ? 100 : 0, max: 100, calc: "${f.predT}¬∞F < ${pFrost}¬∞F", why: "1-Hour projected temperature drop.", exclude: false],
                [label: "Cooling Rate", value: (state.tRate < -pDrop) ? 100 : 0, max: 100, calc: "${state.tRate}¬∞F/hr Drop", why: "Rapid cooling acceleration.", exclude: false]
       
             ], "#ff9800", state.testPredFrost || f.frost.status != "STABLE")
            
            href(name: "toPredMathLink", page: "predictiveMathPage", title: "üìò Learn how Predictive DNA is calculated", description: "Click for Math & Logic Details", width: 12)
        }

        // 7. SENSOR HEALTH
        section() {
        
            def issues = getSensorIssues()
  
           if (issues.size() > 0) {
                def html = """<div style='background:#ffebee; border:1px solid #e57373; border-radius:10px; padding:15px; margin-top:10px;'><h3 style='color:#c62828; margin:0 0 10px 0;'>‚ö†Ô∏è SENSOR DRIFT DETECTED</h3>"""
                issues.each { i -> html += """<div style='color:#b71c1c; font-weight:bold; margin-bottom:5px;'>‚Ä¢ ${i}</div>""" }
                html += "</div>"
                paragraph html
            } else {
                paragraph generateHealthGrid()
            }
        }

        // 8. HAZARD CONTROL CENTER
        section("""<h2 style='color:#263238; font-weight:900; letter-spacing:1px; border-bottom:3px solid #263238; padding-bottom:5px;'>üõ°Ô∏è HAZARD CONTROL CENTER</h2>""") {
            def sLim = stormTriggerPct ?: 60
            def fLim = floodTriggerPct ?: 70
            def frLim = frostTriggerPct ?: 60

            paragraph """
                
<div style='display:flex; justify-content:space-between; align-items:stretch; gap:15px; padding:15px 0;'>
                ${proHazardBlock("STORM", getNormalizedScore("storm"), sLim, "#d32f2f", state.paiStorm ?: 100, state.testStorm || state.simulateScan, getActiveFactors("storm"))}
                ${proHazardBlock("FLOOD", getNormalizedScore("flood"), fLim, "#1976d2", state.paiFlood ?: 100, state.testFlood || state.simulateScan, getActiveFactors("flood"))}
                ${proHazardBlock("FROST", getNormalizedScore("frost"), frLim, "#455a64", state.paiFrost ?: 100, state.testFrost || state.simulateScan, getActiveFactors("frost"))}
            </div>
    
        """
            paragraph """<div style='font-size:0.75em; color:#546e7a; background:#f5f5f5; padding:10px; border-radius:8px; margin-top:5px; border:1px solid #cfd8dc;'><b>üõ°Ô∏è DNA AGGREGATION LOGIC:</b> Scores are normalized based on available data. If a sensor is disabled, the algorithm automatically rebalances the remaining weights to 100%.</div>"""
        }

        // 9. LOGIC TELEMETRY
        section("<h2 style='color:#37474f; font-weight:bold;'>üì° LOGIC TELEMETRY GRID</h2>") {
            paragraph """
            <div style='font-size:0.7em; color:#607d8b; margin-bottom:10px; background:#f5f5f5; padding:10px; border-radius:8px; border:1px solid #e0e0e0;'>
                <b>üìà TREND DECODER:</b><br>
                <span style='color:#d32f2f;'>‚Üë SURGING:</span> Rise > 1.0/hr<br>
                <span style='color:#e65100;'>‚Üó RISING:</span> Rise > 0.5/hr<br>
                <span style='color:#388e3c;'>‚Üí STABLE:</span> Equilibrium<br>
              
  <span style='color:#1976d2;'>‚Üì CRASHING:</span> Drop > 1.0/hr
            </div>
            """
            paragraph generateLogicGrid()
            href(name: "toDataLogs", page: "dataLogPage", title: "üìú VIEW FULL DATA LOGS", description: "Inspect last 50 data points per sensor", width: 12, style:"text-align:center; border:1px solid #ccc; background:#f0f0f0; border-radius:5px;")
        }

        // 10. FORENSIC DNA ANALYSIS
        section("<h2 style='color:#37474f; font-weight:bold;'>üî¨ FORENSIC DNA ANALYSIS</h2>") {
            def t = (state.lastT ?: 0).toDouble().round(1)
            def g = !excludeWind ? (weatherDevice?.currentValue("windGust") ?: 0).toDouble() : 0.0
            def w = !excludeWind ? (state.lastWind ?: 0).toDouble() : 0.0
            def r = !excludeRain ? (weatherDevice?.currentValue("rainRate") ?: 0).toDouble() : 0.0
            def h = (weatherDevice?.currentValue("humidity") ?: 0).toDouble()
            def dew = (state.lastDew ?: 0).toDouble().round(1)
            
            // [NEW] Visual Readout for Locked vs Live
            def gPeak = state.lockedGust ?: g
            def wPeak = state.lockedWind ?: w
            
            paragraph """<div style='background:#fbe9e7; color:#bf360c; padding:10px; border-radius:5px; border:1px solid #ffccbc; font-size:0.85em; display:flex; justify-content:space-around;'>
                <div><b>üí® LIVE GUST</b><br><span style='font-size:1.2em;'>${g} mph</span></div>
                <div style='border-left:1px solid #ffab91; padding-left:15px;'><b>üîí RISK LATCH (60m)</b><br><span style='font-size:1.2em; font-weight:bold;'>${gPeak} mph</span></div>
            </div>"""
    
 
            def lCount = state.lastLit ?: 0
            def lPrev = (state.histLight && state.histLight.size() > 1) ? state.histLight[1].value : 0
            def lDelta = lCount - lPrev
            if (lDelta < 0) lDelta = lCount
        
            def fT_Thresh = (frostTempThreshold ?: 37).toDouble()
            def fT_Bool = (state.fTempWeight ?: 0) > 0 ? "[TRUE]" : "[FALSE]"
            def storm_Bool = (state.wGustWeight ?: 0) > 0 ? "[TRUE]" : "[FALSE]"
            def speed_Bool = (state.wSpeedWeight ?: 0) > 0 ? "[TRUE]" : "[FALSE]"
            def prox_Bool = (state.proxWeight ?: 0) > 0 ? "[TRUE]" : "[FALSE]"
            def surge_Bool = (state.lWeight ?: 0) > 0 ? "[TRUE]" : "[FALSE]"
            def wetBulb_Bool = ((state.wetBulb ?: 99) <= 32.0) ? "[TRUE]" : "[FALSE]"

            // FIX: Using DEFAULT weights for display matching 100-pt scale
            // Gust(15), Rain(10), Light(20), Prox(15), Dew(5), Dark(20), Vector(10)
            paragraph generateDetailedTable("üå™Ô∏è STORM DNA", [
                [label: "Wind Gust", value: (state.wGustWeight ?: 0), max: getTunedWeight("gust"), calc: "${storm_Bool} ${gPeak}mph (60m Latch) >= ${(gustVal ?: 35).toDouble()}mph", why: "Kinetic Energy: Structural stress.", exclude: excludeWind],
  
              [label: "Rain Rate", value: (state.sRainWeight ?: 0), max: getTunedWeight("rain"), calc: "${r}in/hr >= ${(stormRainThreshold ?: 1.0).toDouble()}in/hr", why: "Mass Loading: Adds weight to wind force.", exclude: excludeRain],
                [label: "Lightning Surge", value: (state.lWeight ?: 0), max: getTunedWeight("light"), calc: "${surge_Bool} Delta +${lDelta} >= ${(lightningJumpVal ?: 2)}", why: "Electrical Core: Active strike surge.", exclude: excludeLightning || (state.lightningStale && !state.stormOverrideActive)],
                [label: "Proximity", value: (state.proxWeight ?: 0), max: getTunedWeight("prox"), calc: "${prox_Bool} Dist < ${(lightningDistVal ?: 10)}mi", why: "Hazard Vector: Close range strikes.", exclude: excludeLightning || (state.lightningStale && !state.stormOverrideActive)],
                [label: "Atm. Energy", value: (state.dWeight ?: 0), max: getTunedWeight("dew"), calc: "${dew}¬∞F >= ${(dewPointVal ?: 65).toDouble()}¬∞F", why: "Latent Heat: Moisture fuel for updrafts.", exclude: false],
                [label: "Dark Sky", value: (state.luxWeight ?: 0), max: getTunedWeight("dark"), calc: "Lux Drop > ${(darkSkyDrop ?: 3000)}", why: "Solar Radiance: Rapid clouding.", exclude: excludeLux],
                [label: "Hazard Vector", value: (state.wDirWeight ?: 0), max: getTunedWeight("vector"), calc: "Sector ${badWindStart ?: 225}¬∞-${badWindEnd ?: 315}¬∞", why: "Vector Analysis: Storm track.", exclude: excludeWind]
            ], "#d32f2f", state.testStorm)

            paragraph generateDetailedTable("üåä FLOOD DNA", [
                [label: "Flash Runoff", value: (state.frrWeight ?: 0), max: getTunedWeight("runoff"), calc: "${r}in/hr >= ${(floodRainRate ?: 2.0).toDouble()}in/hr", why: "Surface Velocity: Exceeds drain capacity.", exclude: excludeRain],
               
 [label: "Soil Sat.", value: (state.fsWeight ?: 0), max: getTunedWeight("sat"), calc: "${state.drainageLvl}% >= ${(soilSatLimit ?: 80)}%", why: "Hydraulic Model: Soil bucket full.", exclude: excludeRain]
            ], "#1976d2", state.testFlood)

            def fVaporMax = (frostVaporTempMax ?: 50).toDouble()
            paragraph generateDetailedTable("‚ùÑÔ∏è FROST DNA", [
                [label: "Boundary Temp", value: (state.fTempWeight ?: 0), max: getTunedWeight("ftemp"), calc: "${fT_Bool} ${t}¬∞F <= ${fT_Thresh}¬∞F", why: "Surface Chill: Ground is colder than air.", exclude: false],
        
        [label: "Vapor Load", value: (state.fHumWeight ?: 0), max: getTunedWeight("fhum"), calc: "${h}% >= ${(frostHumThreshold ?: 70)}% & ${t}¬∞F < ${fVaporMax.toInteger()}¬∞F", why: "Ice Deposition: Crystal growth fuel.", exclude: false],
                [label: "Wet Bulb", value: (wetBulb_Bool == "[TRUE]" ? 100 : 0), max: 100, calc: "${wetBulb_Bool} ${state.wetBulb}¬∞F <= 32¬∞F", why: "Evaporative Cooling: Risk to wet vegetation.", exclude: false],
                [label: "Cold Advection", value: (state.fDirWeight ?: 0), max: getTunedWeight("fcold"), calc: "Wind from North (315¬∞-45¬∞)", why: "Air Mass: Arctic air intake.", exclude: excludeWind],
                [label: "Thermal Crash", value: (state.tWeightDrop ?: 0), max: getTunedWeight("fcrash"), calc: "Drop >= ${(tempDropVal ?: 4).toDouble()}¬∞F/hr", why: "Radiative Cooling: Rapid heat loss.", exclude: false]
       
      ], "#455a64", state.testFrost)
 
            href(name: "toForensicMathLink", page: "forensicMathPage", title: "üìò Learn how Forensic DNA is calculated", description: "Click for Normalization & Weight Logic", width: 12)
        }
      
        section() {
           href(name: "reloadPage", page: "mainPage", title: "üîÑ RELOAD PAGE", description: "Force UI Redraw", width: 12, style: "text-align:center;")
        }
  
   }
}

// =================================================================================================
// 6. POLLING & LOGIC ENGINE
// =================================================================================================

def pollWeatherStation(evt = null) {
    if (settings.masterEnable == false && !state.testMode) {
        state.narrative = "üî¥ SYSTEM DISABLED BY MASTER SWITCH."
        controlSwitch?.off()
        floodSwitch?.off()
        frostSwitch?.off()
        predStormSwitch?.off()
        predFloodSwitch?.off()
        predFrostSwitch?.off()
        return
    }
    
    // [NEW] Check External Pause Switch
    if (settings.pauseSwitch && settings.pauseSwitch.currentSwitch == "on" && !state.testMode) {
        state.narrative = "üî¥ SYSTEM PAUSED BY EXTERNAL SWITCH."
        controlSwitch?.off()
        floodSwitch?.off()
        frostSwitch?.off()
        predStormSwitch?.off()
        predFloodSwitch?.off()
        predFrostSwitch?.off()
        return
    }

    def lastActivity = weatherDevice.getLastActivity()
    if (lastActivity && (now() - lastActivity.time) > 3600000) { // 1 Hour
        log.warn "‚ö†Ô∏è STATION OFFLINE: Data is stale (>1h). Entering Safe Mode."
        state.narrative = "üî¥ CRITICAL: STATION DATA STALE. LOGIC HALTED. LAST UPDATE: ${new Date(lastActivity.time).format('h:mm a', location.timeZone)}"
        controlSwitch?.off()
        floodSwitch?.off()
        frostSwitch?.off()
        predStormSwitch?.off()
        predFloodSwitch?.off()
        predFrostSwitch?.off()
        return // Halt Logic
    }

    try {
        state.lastPollStr = new Date().format("h:mm:ss a", location.timeZone)
     
 
        // --- 1. SIMULATION GENERATOR ---
        if (state.simulateScan && state.simTemp == null) {
            def rnd = new Random()
            state.simTemp = rnd.nextInt(70) + 15;
            state.simWind = rnd.nextInt(60); state.simRain = rnd.nextInt(50) / 10.0
            state.simHum = rnd.nextInt(50) + 50;
            state.simGust = state.simWind + 10; state.simLit = rnd.nextInt(20); state.simLux = rnd.nextInt(5000)
            state.lastWindDir = 225
        }
        
        // --- 2. DATA INGESTION ---
        def t = state.simulateScan ? (state.simTemp + (Math.random() * 0.2 - 0.1)) : (state.testFrost ? 20.0 : ((weatherDevice?.currentValue("temperature") ?: 0).toDouble() + (tempOffset ?: 0.0)))
        def h = state.simulateScan ? state.simHum : ((weatherDevice?.currentValue("humidity") ?: 0).toDouble() + (humOffset ?: 0))
        def r = state.simulateScan ? state.simRain : (state.testFlood ? 4.0 : (!excludeRain ? (weatherDevice?.currentValue("rainRate") ?: 0).toDouble() : 0.0))
        
        def g = state.simulateScan ? state.simGust : (state.testStorm ? 60.0 : (!excludeWind ? (weatherDevice?.currentValue("windGust") ?: 0).toDouble() : 0.0))
        def w = state.simulateScan ? state.simWind : (state.testStorm ? 30.0 : (!excludeWind ? (weatherDevice?.currentValue("windSpeed") ?: 0).toDouble() : 0.0))
        def wDir = state.simulateScan ? 225 : (state.testStorm ? 225 : (!excludeWind ? (weatherDevice?.currentValue("windDirection") ?: 0).toInteger() : 0))
        
        // [RESTORED] Check Anomalies before processing
        if (checkAnomalies(t, g, r)) {
            return // Skip this poll to prevent spike damage
        }
        
        def l = 0;
        def lDist = 999
        state.lightningStale = false 

        if (state.simulateScan) {
            l = state.simLit;
            lDist = 5
        } else if (state.testStorm) {
            l = 10;
            lDist = 5
        } else {
            def checkFreshness = { dev, attr ->
                def s = dev.currentState(attr)
                if (s && s.date && (now() - s.date.time) > 3600000) {
                     return false 
  
              }
                return true
            }

            if (extLightning) {
                l = (extLightning.currentValue("lightningCount") ?: extLightning.currentValue("lightning") ?: 0).toInteger()
                def rawDist = (extLightning.currentValue("lightningDistance") ?: 999).toInteger()
                if (!checkFreshness(extLightning, "lightningCount")) { 
                    state.lightningStale = true;
// Note: We do NOT zero out 'l' here yet, to allow for override logic
                }
                lDist = rawDist
            } else if (!excludeLightning) {
                l = (weatherDevice?.currentValue("lightning_num") ?: weatherDevice?.currentValue("lightning") ?: 0).toInteger()
              
                def distAttr = "lightning_distance"
                if (weatherDevice.currentValue("lightningDistance") != null) distAttr = "lightningDistance"
                def rawDist = (weatherDevice?.currentValue(distAttr) ?: 999).toInteger()
                if (!checkFreshness(weatherDevice, "lightning_num") && !checkFreshness(weatherDevice, "lightning")) {
                
                    state.lightningStale = true
                    // Note: We do NOT zero out 'l' here yet, to allow for override logic
                }
                lDist = rawDist
          
              }
        }
      
        def wc = state.simulateScan ? (t - 10).toDouble().round(1) : ((weatherDevice?.currentValue("windChill") ?: t).toDouble()).round(1)
        def lux = state.simulateScan ? state.simLux : (state.testStorm ? 200 : ((luxSensor && !excludeLux) ? (luxSensor.currentValue("illuminance") ?: 0).toInteger() : 0))

        state.lastT = t;
        state.lastH = h; state.lastG = g; state.lastWind = w; state.lastR = r
        state.lastWindDir = wDir;
        state.lastLit = l; state.lastLux = lux; state.lastWC = wc
        state.lastLDist = lDist

        state.feelsLike = calculateFullHeatIndex(t, h)
        state.wetBulb = calculateWetBulb(t, h).toDouble().round(1)

        if (t > state.dayHighTemp) state.dayHighTemp = t
        if (t < state.dayLowTemp) state.dayLowTemp = t
        if (g > state.dayHighGust) state.dayHighGust = g
        if (w > state.dayHighWind) state.dayHighWind = w

    
        double tC = (t - 32) * 5 / 9;
        double rh = h / 100.0
        if (rh > 0) {
            double alpha = Math.log(rh) + (17.62 * tC) / (243.12 + tC)
            double dpC = (243.12 * alpha) / (17.62 - alpha)
            state.lastDew = ((dpC * 9 / 5) + 32).toDouble().round(1)
        } else { state.lastDew = 0.0 }

     
        def useAuto = (enableAutoState == true || enableAutoState == null)
        def pVars = (useAuto && autoState) ? getClimateProfile(autoState) : [gust:35, wind:20, rain:1.0, dew:65, soil:"Silt", flood:2.0, freeze:37, hum:70]
        
        def baseSat = (pVars.soil == "Clay") ? 1.0 : (pVars.soil == "Sand" ? 2.5 : 2.0)
        def evFactor = (t > 80) ? 1.2 : ((t < 40) ? 0.9 : 1.0)
        state.drainageLvl = (((r * 2.0) / (baseSat * evFactor)) * 100).toInteger()
        if (state.drainageLvl > 100) state.drainageLvl = 100

        // --- 4. HISTORY TRACKING (UPDATED WITH SMART COMPRESSION) ---
        updateHistory("histTemp", t);
        updateHistory("histHum", h); 
        updateHistory("histGust", g); 
        updateHistory("histWind", w); 
        updateHistory("histRain", r); updateHistory("histDew", state.lastDew)
        updateHistory("histChill", wc);
        updateHistory("histLight", l); updateHistory("histSat", state.drainageLvl); updateHistory("histLux", lux);
        updateHistory("histBat", weatherDevice.currentValue("battery") ?: 100)
        
        // --- [NEW] PEAK LATCH LOGIC (60 MINS) ---
        // Used for Logic Scoring Only
        def gMax = getPeakLatching(state.histGust, g, 60)
        def wMax = getPeakLatching(state.histWind, w, 60)
        // Store for UI display
        state.lockedGust = gMax
      
        state.lockedWind = wMax

        // --- 5. RATE OF CHANGE (TIME AGNOSTIC) ---
        state.tRate = 0.0;
        state.hRate = 0.0; state.dRate = 0.0; state.wRate = 0.0; state.gRate = 0.0
        
        // Define Window from Settings
        def trendMinutes = (trendTimeSelect ?: "60").toInteger()
        def trendMs = trendMinutes * 60000

        def calcRate = { histList ->
            if (histList && histList.size() >= 2) {
            
                def nEntry = histList[0]
                def nVal = nEntry instanceof Map ? nEntry.value : nEntry
                def nTime = nEntry instanceof Map ? nEntry.time : now()
                // Use Dynamic Window instead of hardcoded 2700000 (45m)
                def oEntry = histList.find { it instanceof Map && (nTime - it.time) >= trendMs }
                if (!oEntry) oEntry = histList.last()
                def oVal = oEntry instanceof Map ? oEntry.value : oEntry
                def oTime = oEntry instanceof Map ? oEntry.time : (now() - 3600000)
                def hrs = (nTime - oTime) / 1000.0 / 3600.0
                return hrs < 0.01 ? 0.0 : ((nVal - oVal) / hrs)
            }
            return 0.0
        }
        
        state.tRate = calcRate(state.histTemp)
        state.hRate = calcRate(state.histHum)
        state.gRate = calcRate(state.histGust)
        state.wRate = calcRate(state.histWind)
        state.dRate = calcRate(state.histDew)

   
     // --- 6. FORENSIC DNA ENGINE ---
        
        // A. FROST LOGIC (Uses Helper)
        def wF_Temp = getTunedWeight("ftemp")
        def wF_Hum = getTunedWeight("fhum")
        def wF_Crash = getTunedWeight("fcrash")
        def wColdAdv = getTunedWeight("fcold")
        def fT_Thresh = (frostTempThreshold ?: 37).toDouble()
        def fH_Thresh = (frostHumThreshold ?: 70).toDouble()
        def fDrop_Thresh = (tempDropVal ?: 4.0).toDouble()
        def tempBonus = (t < (fT_Thresh - 5)) ? 25 : 0
        def fVaporMax = (frostVaporTempMax ?: 50).toDouble()

        state.fTempWeight = (t <= fT_Thresh) ? (wF_Temp + tempBonus) : 0
        state.fHumWeight = (h >= fH_Thresh && t <= fVaporMax) ? wF_Hum : 0
        state.tWeightDrop = (state.tRate <= -fDrop_Thresh) ? wF_Crash : 0
        boolean isNorth = !excludeWind && (wDir >= 315 || wDir <= 45)
        state.fDirWeight = (isNorth && t < 45) ? wColdAdv : 0
        state.rawFrostScore = state.fTempWeight + state.fHumWeight + state.tWeightDrop + state.fDirWeight
        state.frostScore = getNormalizedScore("frost")

        // B. STORM LOGIC (Uses Helper)
        // FIX: Replaced direct weight access with 'getTunedWeight' to enforce 100-pt scale
        def wGust = getTunedWeight("gust")
        def wSpeed = getTunedWeight("wind")
        def wRain = getTunedWeight("rain")
       
        def wLight = getTunedWeight("light")
        def wProx = getTunedWeight("prox")
        def wDew = getTunedWeight("dew")
        def wDark = getTunedWeight("dark")
        
        // Use gMax and wMax (20m Latch) instead of instantaneous g and w for scoring
        state.wGustWeight = (gMax >= (gustVal ?: 35).toDouble()) ? wGust : 0
        state.wSpeedWeight = (wMax >= (windVal ?: 20).toDouble()) ? wSpeed : 0
        state.sRainWeight = (r >= (stormRainThreshold ?: 1.0).toDouble()) ? wRain : 0
        
        state.dWeight = (state.lastDew >= (dewPointVal ?: 65.0).toDouble()) ? wDew : 0
        def luxAvg = 0;
        if (state.histLux.size()>0) luxAvg = state.histLux.collect{it instanceof Map?it.value:it}.sum()/state.histLux.size()
        state.luxWeight = (!excludeLux && lux > 100 && (luxAvg - lux) > (darkSkyDrop ?: 3000).toDouble()) ? wDark : 0
        boolean badWind = !excludeWind && (wDir >= (badWindStart?:225).toInteger() && wDir <= (badWindEnd?:315).toInteger())
        state.wDirWeight = (badWind && g > 10) ? getTunedWeight("vector") : 0
        
        // --- DNA OVERRIDE LOGIC START ---
        // 1. Calculate Score WITHOUT Lightning first to check if > 40%
        def nonLightningRaw = state.wGustWeight + state.wSpeedWeight + state.sRainWeight + state.dWeight + state.luxWeight + state.wDirWeight
        def nonLightningMax = getTunedWeight("gust") + getTunedWeight("wind") + getTunedWeight("rain") + getTunedWeight("dew") + getTunedWeight("dark") + getTunedWeight("vector")
        
       
        def nonLightPct = (nonLightningMax > 0) ? ((nonLightningRaw / nonLightningMax) * 100) : 0
        
        // 2. Determine Validity (If Stale but Score > 40%, we allow it)
        boolean useLightning = true
        state.stormOverrideActive = false
        
        if (state.lightningStale) {
            if (nonLightPct > 40.0) {
   
        
                useLightning = true
                state.stormOverrideActive = true
                state.paiStormWhy = "Stale Data Trusted (DNA > 40%)"
            } else {
                useLightning = false
         
   
        
                state.paiStormWhy = "Data Stale (>1h)"
            }
        } else {
             state.paiStormWhy = "Nominal"
        }
        
        // 3. Calculate Lightning Weights based on validity
 
        def prevL = (state.histLight && state.histLight.size() > 1) ? state.histLight[1].value : 0
        def lDelta = l - prevL
        if (lDelta < 0) lDelta = l
        def lSurgeThreshold = (lightningJumpVal ?: 2).toInteger()
        
        if (useLightning) {
            state.lWeight = (lDelta >= lSurgeThreshold) ? wLight : 0
            state.proxWeight = (lDist <= (lightningDistVal ?: 10).toInteger() && l > 0) ? wProx : 0
        } else {
            state.lWeight = 0
            state.proxWeight = 0
            // Reset lDist if stale and not overridden for safety display
            state.lastLDist = 999 
        }
        // --- DNA OVERRIDE LOGIC END ---

 
        state.rawStormScore = state.wGustWeight + state.wSpeedWeight + state.sRainWeight + state.lWeight + state.proxWeight + state.dWeight + state.luxWeight + state.wDirWeight
        state.currentScore = getNormalizedScore("storm")
        
        // C. FLOOD LOGIC (Uses Helper)
        def wRunoff = getTunedWeight("runoff")
        def wSat = getTunedWeight("sat")
        state.frrWeight = (r >= (floodRainRate ?: 2.0).toDouble()) ? wRunoff : 0
        state.fsWeight = (state.drainageLvl >= (soilSatLimit ?: 80).toInteger()) ? wSat : 0
        state.rawFloodScore = state.frrWeight + state.fsWeight
        state.floodScore = getNormalizedScore("flood")

        // 7. FINAL PROCESSING
        calculatePai()
        
        // [NEW] Update Score History for Timers
        updateHistory("histStormScore", state.currentScore)
        updateHistory("histFloodScore", state.floodScore)
        updateHistory("histFrostScore", state.frostScore)
        
        // [NEW] Calculate Countdown Timers
        calculateCountdowns(calcRate)
        
        checkPredictions()
        checkTriggers()
        buildTacticalReport()
        
    } catch(e) { log.error "Poll Error: ${e}" }
}

def calculateCountdowns(calcRateFunc) {
    // 1. Calculate Rates
    def sRate = calcRateFunc(state.histStormScore)
    def fRate = calcRateFunc(state.histFloodScore)
    def frRate = calcRateFunc(state.histFrostScore)
    
    // 2. Define Thresholds (Local Vars)
    def sLim = (stormTriggerPct ?: 60).toDouble()
    def fLim = (floodTriggerPct ?: 70).toDouble()
    def frLim = (frostTriggerPct ?: 60).toDouble()
    def hyst = (hysteresisVal ?: 5).toDouble()
    
    // 3. Helper to Calc Time
    def calcTime = { current, limit, rate, isClearing ->
        if (isClearing) {
            // How long until we drop below (Limit - Hyst)
            def target = limit - hyst
            if (rate >= 0 || current <= target) return -1
            return (current - target) / Math.abs(rate) * 60 // Minutes
        } else {
            // How long until we rise above Limit
            if (rate <= 0 || current >= limit) return -1
            return (limit - current) / rate * 60 // Minutes
    
        }
    }
    
    // 4. Calculate for Each (Store in State)
    state.stormActive = (controlSwitch && controlSwitch.currentSwitch == "on")
    state.timeToStorm = calcTime(state.currentScore, sLim, sRate, state.stormActive)
    
    state.floodActive = (floodSwitch && floodSwitch.currentSwitch == "on")
    state.timeToFlood = calcTime(state.floodScore, fLim, fRate, state.floodActive)
    
    state.frostActive = (frostSwitch && frostSwitch.currentSwitch == "on")
    state.timeToFrost = calcTime(state.frostScore, frLim, frRate, state.frostActive)
}

// =================================================================================================
// 7. PREDICTION & REPORT ENGINES
// =================================================================================================

def checkPredictions() {
    def pT = ((state.lastT ?: 0.0) + (state.tRate ?: 0.0)).toDouble().round(1)
    def pH = ((state.lastH ?: 0.0) + (state.hRate ?: 0.0)).toDouble().round(0)
    def pD = ((state.lastDew ?: 0.0) + (state.dRate ?: 0.0)).toDouble().round(1)
    
    // PREDICTIVE DNA: USE 20m LATCH
    def g = state.lastG ?: 0.0
    def w = state.lastWind ?: 0.0
    def gMax = getPeakLatching(state.histGust, g, 20)
    def wMax = getPeakLatching(state.histWind, w, 20)
    
    // Calculate raw prediction (Current + Rate)
 
      
    def rawPredG = (g + (state.gRate ?: 0.0)).toDouble().round(1)
    def rawPredW = (w + (state.wRate ?: 0.0)).toDouble().round(1)

    // LOCK LOGIC: Prediction should be at least as high as the Latched Max.
    def pG = (rawPredG > gMax) ? rawPredG : gMax
    def pW = (rawPredW > wMax) ? rawPredW : wMax
    
    def pR = (state.lastR ?: 0.0).toDouble()
    if (pG < 0) pG = 0;
    if (pW < 0) pW = 0; if (pH > 100) pH = 100
    
    def useAuto = (enableAutoState == true || enableAutoState == null)
    def p = (useAuto && autoState) ? getClimateProfile(autoState) : [gust:35, wind:20, rain:1.0, dew:65, soil:"Silt", flood:2.0, freeze:37, hum:70]
    
    def pGustVal = predGustVal != null ? predGustVal.toDouble() : (gustVal != null ? gustVal.toDouble() : p.gust.toDouble())
    def pFrostVal = predFrostTempVal != null ? predFrostTempVal.toDouble() : (frostTempThreshold != null ? frostTempThreshold.toDouble() : p.freeze.toDouble())
    def pLimit = predStormTriggerPct ?: 50
    
    if (state.testPredStorm) pG = pGustVal + 20
    if (state.testPredFrost) pT = pFrostVal - 5
    
    def stormStat = "STABLE";
    def stormCol = "#43a047"
    if (pG > pGustVal || (state.currentScore > pLimit)) { stormStat = "RISING"; stormCol = "#ff9800" }
    if (pG > (pGustVal + 15) || (state.currentScore > 75)) { stormStat = "HIGH"; stormCol = "#d32f2f" }
    if (state.testPredStorm) { stormStat = "PRE-ALERT"; stormCol = "#ff9800" }
    
    def floodStat = "STABLE";
    def floodCol = "#43a047"
    if (state.floodScore > (predFloodTriggerPct ?: 50)) { floodStat = "RISING"; floodCol = "#ff9800" }
    if (state.floodScore > 75) { floodStat = "HIGH"; floodCol = "#d32f2f" }
    if (state.testPredFlood) { floodStat = "PRE-ALERT"; floodCol = "#ff9800" }
    
    def frostStat = "STABLE";
    def frostCol = "#43a047"
    if (pT < pFrostVal || state.frostScore > (predFrostTriggerPct ?: 50)) { frostStat = "RISK"; frostCol = "#ff9800" }
    if (pT < 32 || state.frostScore > 75) { frostStat = "FREEZE"; frostCol = "#d32f2f" }
    if (state.testPredFrost) { frostStat = "PRE-ALERT"; frostCol = "#ff9800" }

    state.forecast = [
        storm: [status: stormStat, color: stormCol],
        flood: [status: floodStat, color: floodCol],
        frost: [status: frostStat, color: frostCol],
        predT: pT, predH: pH.toInteger(), predD: pD, predG: pG, predW: pW, predR: pR
    ]
}

def buildTacticalReport() {
    def lines = []
    def t = state.lastT ?: 70;
    def g = state.lastG ?: 0; def w = state.lastWind ?: 0
    def r = state.lastR ?: 0;
    def l = state.lastLit ?: 0; def lDist = state.lastLDist ?: 999
    def fT_Thresh = (frostTempThreshold ?: 37).toDouble()
    
    if (settings.masterEnable == false && !state.testMode) {
        state.narrative = "üî¥ SYSTEM DISABLED. LOGIC HALTED.";
        return
    }
    if (state.testMode) {
        lines.add("<span style='color:purple'>‚ö†Ô∏è SIMULATION/TEST OVERRIDE ACTIVE.</span>")
    }

    if (t <= 30.0 || state.testFrost) lines.add("<span style='color:#b71c1c'><b>‚ùÑÔ∏è HARD FREEZE:</b> Critical thermal failure (<30¬∞F). Pipe burst risk imminent.</span>")
    else if (t <= fT_Thresh) lines.add("<span style='color:blue'><b>‚ùÑÔ∏è FREEZE WARNING:</b> Surface temps below threshold. Protect vegetation.</span>")
    else if ((state.wetBulb ?: 99) <= 34.0) lines.add("<span style='color:blue'><b>üíß WET BULB RISK:</b> Evaporative cooling at ${state.wetBulb}¬∞F. Frost likely on wet surfaces.</span>")
    else if (state.frostScore >= (frostTriggerPct ?: 60)) 
 
 
    lines.add("<b>‚ùÑÔ∏è COLD FRONT:</b> Approaching freeze threshold. Monitor heating.")
    else lines.add("<b>üå°Ô∏è THERMAL:</b> ${t}¬∞F (Stable).")
  
    if (state.currentScore >= (stormTriggerPct ?: 60) || state.testStorm) {
        def stormStr = "<span style='color:red'><b>üå™Ô∏è STORM TRACKING:</b></span>"
        if (state.wGustWeight > 0) stormStr += " Kinetic Energy (Gusts)."
        if (state.wSpeedWeight > 0) stormStr += " <b>SUSTAINED WINDS.</b>"
        if (state.sRainWeight > 0) stormStr += " Heavy precip loading."
        if (!state.lightningStale || state.stormOverrideActive) {
            if (state.lWeight > 0) stormStr += " Electrical Activity detected (${l} strikes)."
            if (state.proxWeight > 0) stormStr += " <b>CLOSE PROXIMITY STRIKE (${lDist} mi).</b>"
        }
        lines.add(stormStr)
    } else {
        if (g > 20 || w > 15) lines.add("<b>üí® WIND:</b> Elevated breeze (W:${w}/G:${g} mph).")
        else lines.add("<b>üí® WIND:</b> Nominal (${g}mph).")
    }
    
    if (state.floodScore >= (floodTriggerPct ?: 70) || state.testFlood) {
        lines.add("<span style='color:#0d47a1'><b>üåä FLOOD RISK CRITICAL:</b> Soil saturation ${state.drainageLvl}%. Runoff velocity high.</span>")
    } else if (r > 0) {
         lines.add("<b>üåßÔ∏è RAIN:</b> Active precip (${r} in/hr). Drainage stable.")
    }

    def trends = []
    if ((state.tRate ?: 0) < -1.5) trends.add("Rapid Temp Drop")
    if ((state.gRate ?: 0) > 5.0) trends.add("Gusts Surging")
    if ((state.wRate ?: 0) > 3.0) trends.add("Winds Building")
    if ((!state.lightningStale || state.stormOverrideActive) && l > 0 && lDist > 20) trends.add("Distant Thunder")
    
    
    if (trends.size() > 0) lines.add("<b>üìà TRENDS:</b> " + trends.join(", ") + ".")
    else lines.add("Conditions stable.")
    state.narrative = lines.join(" ")
}

// =================================================================================================
// 8. BUTTON HANDLER & HELPERS
// =================================================================================================

def sendNotification(msg) {
    if (notifDevice) {
        log.info "Notification Sent: ${msg}"
        notifDevice.deviceNotification(msg)
    }
}

def appButtonHandler(btn) { 
    if (btn == "completeSetupBtn") { state.setupComplete = true;
    initialize(); pollWeatherStation() }
  
    else if (btn == "testStormBtn") { 
        state.testMode = true;
        state.simulateScan = false; state.testStorm = true;
        state.testFlood = false; state.testFrost = false; state.testPredStorm = false; state.testPredFlood = false;
        state.testPredFrost = false;
        sendNotification("üß™ TEST INITIATED: Storm Alarm Simulation. Watch for activation...")
        pollWeatherStation() 
    }
    else if (btn == "testFloodBtn") { 
        state.testMode = true;
        state.simulateScan = false; state.testStorm = false;
        state.testFlood = true; state.testFrost = false; 
        state.testPredStorm = false; state.testPredFlood = false;
        state.testPredFrost = false;
        sendNotification("üß™ TEST INITIATED: Flood Alarm Simulation. Watch for activation...")
        pollWeatherStation() 
    }
    else if (btn == "testFrostBtn") { 
        state.testMode = true;
        state.simulateScan = false; state.testStorm = false;
        state.testFlood = false; state.testFrost = true; 
        state.testPredStorm = false; state.testPredFlood = false;
        state.testPredFrost = false;
        sendNotification("üß™ TEST INITIATED: Frost Alarm Simulation. Watch for activation...")
        pollWeatherStation() 
    }
    else if (btn == "testPredStormBtn") { 
        state.testMode = true;
        state.simulateScan = false;
        state.testStorm = false; state.testFlood = false; state.testFrost = false;
        state.testPredStorm = true; state.testPredFlood = false;
        state.testPredFrost = false;
        sendNotification("üß™ TEST INITIATED: Predictive Storm Watch Simulation...")
        pollWeatherStation() 
    }
    else if (btn == "testPredFloodBtn") { 
        state.testMode = true;
        state.simulateScan = false;
        state.testStorm = false; state.testFlood = false; state.testFrost = false;
        state.testPredStorm = false; state.testPredFlood = true;
        state.testPredFrost = false;
        sendNotification("üß™ TEST INITIATED: Predictive Flood Watch Simulation...")
        pollWeatherStation() 
    }
    else if (btn == "testPredFrostBtn") { 
        state.testMode = true;
        state.simulateScan = false;
        state.testStorm = false; state.testFlood = false; state.testFrost = false;
        state.testPredStorm = false; state.testPredFlood = false;
        state.testPredFrost = true;
        sendNotification("üß™ TEST INITIATED: Predictive Frost Watch Simulation...")
        pollWeatherStation() 
    }
    
    else if (btn == "clearBtn") { resetSystem() }
    else if (btn == "hardResetBtn") { hardWipe() }
    else if (btn == "refreshBtn") { state.testMode = false;
    state.simulateScan = false; initialize(); if (weatherDevice.hasCommand("refresh")) { log.info "Refreshing..."; weatherDevice.refresh() };
    pollWeatherStation() 
    }
    else if (btn == "refreshLogs") { 
        log.info "Refreshing Data Logs..."
        pollWeatherStation() 
    }
    else if (btn == "forceSimBtn") { runSimulatedScan() }
    else if (btn == "reloadPageBtn") { log.info "Page Reload" }
}

def runSimulatedScan() {
    state.testMode = false;
    state.simulateScan = true
    state.narrative = "üß™ SIMULATION ACTIVE: Injecting Synthetic Weather Data (Cycle starting)..."
    generateRandomSimData()
    schedule("0 */5 * * * ?", generateRandomSimData)
}

def generateRandomSimData() {
    def rnd = new Random()
    state.simTemp = rnd.nextInt(70) + 15;
    state.simWind = rnd.nextInt(60); state.simRain = rnd.nextInt(50) / 10.0
    state.simHum = rnd.nextInt(50) + 50;
    state.simGust = state.simWind + 10; state.simLit = rnd.nextInt(20); state.simLux = rnd.nextInt(5000)
    state.narrative = "üé≤ SIMULATION CYCLE: Temp ${state.simTemp}¬∞F | Wind ${state.simWind}mph | Rain ${state.simRain}in"
    pollWeatherStation() 
}

def resetSystem() { 
    unschedule("generateRandomSimData")
    state.testMode = false;
    state.simulateScan = false
    state.testStorm = false; state.testFlood = false; state.testFrost = false;
    state.testPredStorm = false;
    state.testPredFlood = false; state.testPredFrost = false;
    state.simTemp = null
    state.currentScore = 0;
    state.floodScore = 0;
    state.frostScore = 0
    state.rawStormScore = 0; state.rawFloodScore = 0;
    state.rawFrostScore = 0
    state.wGustWeight = 0; state.wSpeedWeight = 0; state.sRainWeight = 0; 
    state.lWeight = 0;
    state.dWeight = 0; state.luxWeight = 0; state.wDirWeight = 0; state.proxWeight = 0
    state.frrWeight = 0;
    state.fsWeight = 0; state.fTempWeight = 0;
    state.fHumWeight = 0; state.tWeightDrop = 0;
    state.fDirWeight = 0
    state.forecast = [storm:[status:"STABLE", color:"#43a047"], flood:[status:"STABLE", color:"#43a047"], frost:[status:"STABLE", color:"#43a047"], predT:0, predH:0, predD:0, predW:0, predG:0, predR:0]
    state.alertHistory = []
    state.lastTriggerTime = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]
    state.activeEventStart = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]
    state.narrative = "‚úÖ ALERTS CLEARED & TIMERS RESET. RESUMING LIVE DATA STREAM..."
    state.stormOverrideActive = false
    state.lightningStale = false
    controlSwitch?.off();
    floodSwitch?.off(); frostSwitch?.off()
    predStormSwitch?.off(); predFloodSwitch?.off(); predFrostSwitch?.off();
    
    // [NEW] Clear Timers
    state.timeToStorm = -1;
    state.timeToFlood = -1; state.timeToFrost = -1
    
    runIn(1, "pollWeatherStation") 
}

def hardWipe() {
    state.histTemp=[];
    state.histHum=[]; state.histGust=[]; state.histWind=[];
    state.histRain=[];
    state.histDew=[]; state.histChill=[]; state.histLight=[]; state.histSat=[]; state.histBat=[]; state.histLux=[];
    state.histStormScore=[]; state.histFloodScore=[]; state.histFrostScore=[];
    state.anomalies=[]
    resetSystem()
}

// =================================================================================================
// 9. SUB-PAGES & PLACEHOLDERS
// =================================================================================================

def updateHistory(key, val) {
    if (state[key] == null) state[key] = []
    def lastEntry = state[key].size() > 0 ? state[key][0] : null
    def lastVal = lastEntry instanceof Map ? lastEntry.value : null
    def lastTime = lastEntry instanceof Map ? lastEntry.time : 0
    if (lastVal == val && (now() - lastTime) < 1800000) { 
        if (state[key].size() > 0) state[key][0].time = now()
    } else {
        def entry = [value: val, time: now()]
        state[key].add(0, entry)
        if (state[key].size() > 50) state[key] = state[key].take(50)
    }
}

def checkAnomalies(t, g, r) { 
    def issues = []
    if (state.histTemp && state.histTemp.size() > 0) 
 
    {
        def lastT = state.histTemp[0] instanceof Map ? state.histTemp[0].value : state.histTemp[0]
        if (Math.abs(t - lastT) > 15.0) issues.add("Thermal Shock")
    }
    if (g > 200) issues.add("Gust Sensor Maxed")
    if (issues.size() > 0) {
        log.warn "‚ö†Ô∏è DATA SPIKE DETECTED: ${issues}. Skipping Logic."
        state.anomalies = issues.collect { [type: it, time: now()] }
        return true 
    }
    state.anomalies = []
    return false
}

def calculatePai() {
    state.paiStorm = 100;
    state.paiFlood = 100; state.paiFrost = 100
}

def logTrigger(type, isOn) {
    if (!state.activeEventStart) state.activeEventStart = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]
    if (!state.alertHistory) state.alertHistory = []
    def key = ""
    if (type == "STORM") key = "storm"
    else if (type == "FLOOD") key = "flood"
    else if (type == "FROST") key = "frost"
    else if (type == "PRE-STORM") key = "pStorm"
    else if (type == "PRE-FLOOD") key = "pFlood"
    else if (type == "PRE-FROST") key = "pFrost"
    
    if (isOn) {
        state.activeEventStart[key] = now()
    } else {
        def start = state.activeEventStart[key]
        if (start > 0) {
            def diff = now() - start
            def dur = ""
            if (diff < 60000) dur = 
            "${(diff/1000).toInteger()}s"
            else dur = "${(diff/60000).toInteger()}m"
            def entry = [type: type, time: new Date(start).format("MM-dd HH:mm", location.timeZone), duration: dur]
            state.alertHistory.add(0, entry)
            if (state.alertHistory.size() > 20) 
                state.alertHistory = state.alertHistory.take(20)
   
            state.activeEventStart[key] = 0 
            // Reset
        }
    }
}

def checkTriggers() {
    if (settings.masterEnable == false && !state.testMode) {
        controlSwitch?.off();
        floodSwitch?.off(); frostSwitch?.off()
        predStormSwitch?.off(); predFloodSwitch?.off();
        predFrostSwitch?.off()
        return
    }
    
    // [NEW] Check External Pause Switch
    if (settings.pauseSwitch && settings.pauseSwitch.currentSwitch == "on" && !state.testMode) {
        return
    }

    def sLim = stormTriggerPct ?: 60
    def fLim = floodTriggerPct ?: 70
    def frLim = frostTriggerPct ?: 60
    def hyst = hysteresisVal ?: 5
    def psLim = predStormTriggerPct ?: 50
    def pfLim = predFloodTriggerPct ?: 50
    def pfrLim = predFrostTriggerPct ?: 50
    def minRunTime = 300000 // 5 Minutes in ms

    def canTrigger = { key ->
    
 
        if (state.testMode || state.testPredStorm || state.testPredFlood || state.testPredFrost) return true 
        def lastT = state.lastTriggerTime ? state.lastTriggerTime[key] : 0
        def delayMs = (triggerDelay ?: 0) * 60000
        return (now() - lastT) > delayMs
    }

    def markTrigger = { key ->
        if (!state.lastTriggerTime) state.lastTriggerTime = [storm:0, flood:0, frost:0, pStorm:0, pFlood:0, pFrost:0]
        state.lastTriggerTime[key] = now()
    }

    // STORM LOGIC
    boolean activeStorm = (state.testStorm || (!state.testPredStorm && state.currentScore >= sLim))
    boolean stormOffCondition = !state.testStorm && state.currentScore < (sLim - hyst)
    if (activeStorm) {
        if (canTrigger("storm") || (controlSwitch && controlSwitch.currentSwitch == "on")) { 
            if (controlSwitch && controlSwitch.currentSwitch != "on") { 
                controlSwitch?.on();
                logTrigger("STORM", true); markTrigger("storm") 
                def reason = state.testStorm ? "Manual Test" : "Score ${state.currentScore}% > ${sLim}%"
                if ((settings.notifyStorm ?: "Active Only") != "Disabled") sendNotification("üö® STORM ALARM ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('storm')}\nTime: ${new Date().format('h:mm a')}")
            }
        }
    } else if (stormOffCondition) { 
        def timeActive = now() - (state.activeEventStart['storm'] ?: 0)
        if (controlSwitch && controlSwitch.currentSwitch == "on" && timeActive > minRunTime) { 
 
       
            controlSwitch?.off();
            logTrigger("STORM", false) 
            if ((settings.notifyStorm ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ STORM ALL CLEAR: Conditions stabilized below threshold.")
        }
    }

    // PREDICTIVE STORM LOGIC (FIXED NULL SAFETY)
    def stormRisk = (state.forecast?.storm?.status == "RISING") || (state.forecast?.storm?.status == "HIGH") || (state.forecast?.storm?.status == "PRE-ALERT")
    boolean triggerPredStorm = state.testPredStorm || (stormRisk && !state.testStorm && state.currentScore >= psLim)
    if (triggerPredStorm) {
        log.debug "Pred Storm Trigger Active. Checking Switch..."
        if (canTrigger("pStorm") || (predStormSwitch && predStormSwitch.currentSwitch == "on")) {
            if (predStormSwitch && predStormSwitch.currentSwitch != "on") { 
                predStormSwitch?.on();
                logTrigger("PRE-STORM", true); markTrigger("pStorm") 
                def reason = state.testPredStorm ? "Manual Test" : "Score ${state.currentScore}% > ${psLim}% (Trend Rising)"
                if ((settings.notifyPredStorm ?: "Active Only") != "Disabled") sendNotification("üîÆ PRE-STORM WATCH ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('storm')}\nTime: ${new Date().format('h:mm a')}")
            }
        }
    } else { 
        if (predStormSwitch && predStormSwitch.currentSwitch == "on") { 
            predStormSwitch?.off();
            logTrigger("PRE-STORM", false)
            if ((settings.notifyPredStorm ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ PRE-STORM WATCH ENDED.")
        }
    }

    // FLOOD LOGIC
    boolean activeFlood = (state.testFlood || (!state.testPredFlood && state.floodScore >= fLim))
    boolean floodOffCondition = !state.testFlood && state.floodScore < (fLim - hyst)
    if (activeFlood) {
        if (canTrigger("flood") || (floodSwitch && floodSwitch.currentSwitch == "on")) {
        
            if (floodSwitch && floodSwitch.currentSwitch != "on") { 
                floodSwitch?.on();
                logTrigger("FLOOD", true); markTrigger("flood")
                def reason = state.testFlood ? "Manual Test" : "Score ${state.floodScore}% > ${fLim}%"
                if ((settings.notifyFlood ?: "Active Only") != "Disabled") sendNotification("üåä FLOOD ALARM ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('flood')}\nTime: ${new Date().format('h:mm a')}")
            }
        }
    } else if (floodOffCondition) { 
        def timeActive = now() - (state.activeEventStart['flood'] ?: 0)
        if (floodSwitch && floodSwitch.currentSwitch == "on" && timeActive > minRunTime) { 
 
       
             floodSwitch?.off();
             logTrigger("FLOOD", false) 
             if ((settings.notifyFlood ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ FLOOD ALL CLEAR: Conditions stabilized below threshold.")
        }
    }

    // PREDICTIVE FLOOD LOGIC (FIXED NULL SAFETY)
    def floodRisk = (state.forecast?.flood?.status == "RISING") || (state.forecast?.flood?.status == "HIGH") || (state.forecast?.flood?.status == "PRE-ALERT")
    boolean triggerPredFlood = state.testPredFlood || (floodRisk && !state.testFlood && state.floodScore >= pfLim)
    if (triggerPredFlood) {
        if (canTrigger("pFlood") || (predFloodSwitch && predFloodSwitch.currentSwitch == "on")) {
             if (predFloodSwitch && predFloodSwitch.currentSwitch != "on") { 
                 predFloodSwitch?.on();
                 logTrigger("PRE-FLOOD", true); markTrigger("pFlood") 
                 def reason = state.testPredFlood ? "Manual Test" : "Score ${state.floodScore}% > ${pfLim}% (Trend Rising)"
                 if ((settings.notifyPredFlood ?: "Active Only") != "Disabled") sendNotification("üîÆ PRE-FLOOD WATCH ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('flood')}\nTime: ${new Date().format('h:mm a')}")
             }
        }
    } else { 
        if (predFloodSwitch && predFloodSwitch.currentSwitch == "on") { 
            predFloodSwitch?.off();
            logTrigger("PRE-FLOOD", false) 
            if ((settings.notifyPredFlood ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ PRE-FLOOD WATCH ENDED.")
        }
    }

    // FROST LOGIC
    def hardFreeze = (state.lastT ?: 99) <= (frostTempThreshold ?: 37)
    def wetBulbFreeze = (state.wetBulb ?: 99) <= 32.0
    boolean activeFrost = (state.testFrost || (!state.testPredFrost && (state.frostScore >= frLim) || hardFreeze || wetBulbFreeze))
    boolean frostOffCondition = !state.testFrost && (state.frostScore < (frLim - hyst)) && !hardFreeze && !wetBulbFreeze
    if (activeFrost) {
        if (canTrigger("frost") || (frostSwitch && frostSwitch.currentSwitch == "on")) {
        
            if (frostSwitch && frostSwitch.currentSwitch != "on") { 
                frostSwitch?.on();
                logTrigger("FROST", true);
                markTrigger("frost") 
                def reason = state.testFrost ? "Manual Test" : (wetBulbFreeze ? "Wet Bulb ${state.wetBulb}¬∞F <= 32¬∞F" : "Score ${state.frostScore}% > ${frLim}%")
                if ((settings.notifyFrost ?: "Active Only") != "Disabled") sendNotification("‚ùÑÔ∏è FROST ALARM ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('frost')}\nTime: ${new Date().format('h:mm a')}")
            }
        }
    } else if (frostOffCondition) { 
        def timeActive = now() - (state.activeEventStart['frost'] ?: 0)
        if (frostSwitch && frostSwitch.currentSwitch == "on" && timeActive > minRunTime) 
        { 
            frostSwitch?.off();
            logTrigger("FROST", false) 
            if ((settings.notifyFrost ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ FROST ALL CLEAR: Conditions stabilized below threshold.")
        }
    }

    // PREDICTIVE FROST LOGIC (FIXED NULL SAFETY)
    def frostRisk = (state.forecast?.frost?.status == "RISK") || (state.forecast?.frost?.status == "FREEZE") || (state.forecast?.frost?.status == "PRE-ALERT")
    boolean triggerPredFrost = state.testPredFrost || (frostRisk && !state.testFrost && state.frostScore >= pfrLim)
    if (triggerPredFrost) {
        if (canTrigger("pFrost") || (predFrostSwitch && predFrostSwitch.currentSwitch == "on")) {
             if (predFrostSwitch && predFrostSwitch.currentSwitch != "on") { 
                 predFrostSwitch?.on();
                 logTrigger("PRE-FROST", true); markTrigger("pFrost") 
                 def reason = state.testPredFrost ? "Manual Test" : "Score ${state.frostScore}% > ${pfrLim}% (Trend Falling)"
                 if ((settings.notifyPredFrost ?: "Active Only") != "Disabled") sendNotification("üîÆ PRE-FROST WATCH ACTIVE\nWhy: ${reason}\nFactors: ${getActiveFactors('frost')}\nTime: ${new Date().format('h:mm a')}")
             }
        }
    } else { 
        if (predFrostSwitch && predFrostSwitch.currentSwitch == "on") { 
            predFrostSwitch?.off();
            logTrigger("PRE-FROST", false) 
            if ((settings.notifyPredFrost ?: "Active Only") == "Active & All Clear") sendNotification("‚úÖ PRE-FROST WATCH ENDED.")
        }
    }
}

// =================================================================================================
// 10. PAGES DEFINITIONS
// =================================================================================================

def configurePage() {
    dynamicPage(name: "configurePage", title: "üõ†Ô∏è DEVICE SETUP") {
        section() { paragraph "Connect physical sensors and relays." }
        section("1. Primary Sensors") {
            input "weatherDevice", "capability.temperatureMeasurement", title: "üå°Ô∏è Weather Station", required: true, multiple: false
            input "extLightning", "capability.sensor", title: "‚ö° Dedicated Lightning (Optional)", required: false
            input "luxSensor", "capability.illuminanceMeasurement", title: "‚òÄÔ∏è Lux (Optional)", required: false
        }
        section("2. Hazard Relays") {
       
             input "controlSwitch", "capability.switch", title: "üå™Ô∏è Storm Relay", required: false
            input "floodSwitch", "capability.switch", title: "üåä Flood Relay", required: false
            input "frostSwitch", "capability.switch", title: "‚ùÑÔ∏è Frost Relay", required: false
        }
        section("3. Predictive Relays") {
            input "predStormSwitch", "capability.switch", title: "üîÆ Pre-Storm", required: false
 
       
             input "predFloodSwitch", "capability.switch", title: "üîÆ Pre-Flood", required: false
            input "predFrostSwitch", "capability.switch", title: "üîÆ Pre-Frost", required: false
        }
        section("4. Controls") {
            input "masterEnable", "bool", title: "üü¢ Enable System Logic?", defaultValue: true, required: true
            
            paragraph "<div style='font-size:0.8em; color:#555; background:#f5f5f5; padding:8px; border-radius:5px; margin-bottom:10px; border:1px solid #e0e0e0;'><b>‚ÑπÔ∏è TRIGGER DELAY EXPLAINED:</b><br>This creates a mandatory 'Cooldown Period' after an alert triggers. During this time, the specific alarm cannot trigger again, even if conditions remain critical.<br>‚Ä¢ <b>Purpose:</b> Prevents 'flapping' (rapid on/off switching) and notification spam during lingering storms.<br>‚Ä¢ <b>Recommendation:</b> Set to <b>30-60 Minutes</b> for stable operation.</div>"
            
            input "triggerDelay", "number", title: "‚è±Ô∏è Trigger Delay (Min)", defaultValue: 0, required: true
        }
    }
}

def trustPage() {
    dynamicPage(name: "trustPage", title: "üõ°Ô∏è PAI TRUST DIAGNOSTICS") {
       section("üîé Forensic Accuracy Calculation") {
            paragraph trustRow("STORM TRUST", state.paiStorm ?: 100, state.paiStormWhy ?: "Nominal", "#d32f2f")
            paragraph trustRow("FLOOD TRUST", state.paiFlood ?: 100, state.paiFloodWhy ?: "Nominal", "#1976d2")
            paragraph trustRow("FROST TRUST", state.paiFrost ?: 100, state.paiFrostWhy ?: "Nominal", "#455a64")
        }
    }
}

def predictiveMathPage() {
    dynamicPage(name: "predictiveMathPage", title: "üß¨ PREDICTIVE DNA: THE MATH") {
       section("The Prediction Engine") {
            paragraph """
   
         <div style='font-family:sans-serif; color:#444;'>
                <h4 style='color:#0d47a1;'>1. Linear Trend Extrapolation</h4>
                <p>The system predicts conditions <b>1 Hour</b> into the future by analyzing the Rate of Change (RoC) over the last 45-60 minutes.</p>
                <div style='background:#e3f2fd; padding:10px; border-left:3px solid #0d47a1; font-family:monospace;'>
                    P_future = Current_Val + (Rate * 1.0hr)
                </div>
                
                <h4 style='color:#0d47a1; margin-top:15px;'>2. Peak Latching (20m)</h4>
                <p>To prevent rapid oscillation (flapping) during lulls in a storm, the prediction engine uses a "Latch" mechanism. It compares the current live reading against the <b>Maximum Value</b> recorded in the last 20 minutes.</p>
                <p><i>If the live wind speed drops, the system holds onto the peak value for 20 minutes to keep alerts active during temporary calm periods.</i></p>

                <h4 style='color:#0d47a1; margin-top:15px;'>3. Rate Calculation</h4>
                <p>Rates are calculated by comparing the newest data point to the oldest data point available within a 1-hour buffer.</p>
                <div style='background:#f5f5f5; padding:5px; font-size:0.9em;'>
                ‚Ä¢ <b>Rising:</b> > +0.5 units/hr (Trend Up)<br>
                ‚Ä¢ <b>Surging:</b> > +1.0 units/hr (Fast Rise)<br>
                ‚Ä¢ <b>Crashing:</b> < -1.0 units/hr (Fast Drop)
                </div>
            </div>
     
       """
        }
    }
}

def forensicMathPage() {
    dynamicPage(name: "forensicMathPage", title: "üî¨ FORENSIC DNA: THE MATH") {
        section("The Weighted Algorithm") {
            paragraph """
            <div style='font-family:sans-serif; color:#444;'>
                <h4 style='color:#2e7d32;'>1. Weighted Normalization</h4>
                <p>The "Hazard Score" (0-100%) is not a simple average. It is a weighted sum of all <b>active</b> sensors.</p>
                <div style='background:#e8f5e9; padding:10px; border-left:3px solid #2e7d32; font-family:monospace;'>
                    Score = (Sum of Active Weights / Sum of Possible Weights) * 100
                </div>
                <p>If a sensor is disabled or excluded, it is removed from the "Possible Weights" denominator, ensuring the score scales correctly to 100% using only the remaining sensors.</p>

      
          <h4 style='color:#2e7d32; margin-top:15px;'>2. Stale Data & Override Logic</h4>
                <p><b>Standard Safety:</b> If a sensor (e.g., Lightning) stops reporting for >1 hour, it is marked "Stale" and its weight is removed to prevent false positives.</p>
                <p><b>Storm Override:</b> If the other sensors (Wind, Rain, Pressure) indicate a strong storm (Score > 40%), the system will <b>ignore the Stale flag</b> and use the last known lightning data. This ensures we don't lose critical alerts just because the lightning sensor went offline during a severe event.</p>

                <h4 style='color:#2e7d32; margin-top:15px;'>3. DNA Composition</h4>
                <div style='font-size:0.9em;'>
                ‚Ä¢ <b>Storm DNA:</b> Kinetic (Wind/Gust) + Mass (Rain) + Electric (Lightning) + Potential (Dew Point/Lux)<br>
                ‚Ä¢ <b>Flood DNA:</b> Hydraulics (Soil Saturation) + Runoff (Rain Rate)<br>
                ‚Ä¢ <b>Frost DNA:</b> Thermodynamics (Temp/WetBulb) + Crystal Growth (Humidity) + Advection (Wind Dir)
                </div>
            </div>
            """
        }
    }
}

def calibrationPage() {
    dynamicPage(name: "calibrationPage", title: "‚öôÔ∏è SYSTEM CALIBRATION") {
        section("‚ö†Ô∏è Warning") {
            paragraph "Adjusting these settings changes the core physics engine."
    
    }
        section("üî¨ Hazard DNA Modules") {
            href(name: "toStormConfig", page: "stormConfigPage", title: "üå™Ô∏è Storm Calibration", description: "Gusts, Rain, Lightning")
            href(name: "toFloodConfig", page: "floodConfigPage", title: "üåä Flood Calibration", description: "Saturation, Runoff")
            href(name: "toFrostConfig", page: "frostConfigPage", title: "‚ùÑÔ∏è Frost Calibration", description: "Freeze, Thermodynamics")
            href(name: "toRegionConfig", page: "regionConfigPage", title: 
"üá∫üá∏ Regional Physics", description: "Soil, Wind & Thermal Profiles")
        }
        section("üéöÔ∏è Advanced Tuning") {
            href(name: "toWeightConfig", page: "weightConfigPage", title: "‚öñÔ∏è DNA Weighting", description: "Algorithm Balance (100% Scale)")
            href(name: "toSystemConfig", page: "systemConfigPage", title: "‚öôÔ∏è System & Alerts", description: "Hardware, Delays, Region")
        }
    }
}

def regionConfigPage() {
    dynamicPage(name: "regionConfigPage", title: "üá∫üá∏ REGIONAL PHYSICS CALIBRATION") 
{
        section() {
            paragraph """
            <div style='background:#f0f4c3; padding:15px; border-radius:5px; border-left:5px solid #c0ca33;'>
                <h4 style='margin:0 0 10px 0; color:#827717;'>Why Regional Physics?</h4>
                <p style='margin:0; font-size:0.9em; color:#555;'>
                    A storm in Arizona behaves differently than a storm in Florida. This module calibrates the core physics engine to match your local climate profile:
                    <ul style='margin-top:10px;'>
                        <li><b>üíß Soil Hydraulics:</b> Adjusts flood saturation rates for clay vs. sand.</li>
                        <li><b>‚òÄÔ∏è Evaporation:</b> Modifies surface drying rates (Arid vs. Humid).</li>
 
                       <li><b>üí® Wind Profiles:</b> Tunes gust baselines for Coastal vs. Plains environments.</li>
                        <li><b>‚ùÑÔ∏è Thermal Thresholds:</b> Calibrates freeze warnings for Northern vs. Southern infrastructure.</li>
                    </ul>
             
   </p>
            </div>
            """
        }
        section("üåç Location Profile") {
            input "enableAutoState", "bool", title: "Enable Regional Physics?", defaultValue: true, submitOnChange: true
            if (enableAutoState) {
                input(name: "autoState", 
type: "enum", title: "Select US State", options: getUSStates(), submitOnChange: true)
                input(name: "mountLocation", type: "enum", title: "Mount Height", options: ["ground", "roof"], defaultValue: "roof", submitOnChange: true)
            }
        }
    }
}

def stormConfigPage() {
    dynamicPage(name: "stormConfigPage", title: "üå™Ô∏è STORM CALIBRATION") {
        section("üí® Wind & Kinetic") {
            paragraph "<b>Gust Limit:</b> Speed at which wind creates structural risk."
            input "gustVal", "number", title: "Gust Limit (mph)", defaultValue: 35
            paragraph "<b>Sustained Wind:</b> Continuous force threshold."
            input "windVal", "number", title: "Sustained Wind (mph)", defaultValue: 20
            paragraph "<b>Vector Analysis:</b> Direction associated with storm fronts."
             input "badWindStart", "number", title: "Wind Vector Start (¬∞)", defaultValue: 225
            input "badWindEnd", "number", title: "Wind Vector End (¬∞)", defaultValue: 315
        }
        section("‚ö° Electrical & Atmos") {
            paragraph "<b>Lightning Surge:</b> Sudden jump in strike count."
            input "lightningJumpVal", "number", title: "Lightning Surge (strikes)", defaultValue: 2
            paragraph "<b>Proximity:</b> Radius for immediate danger."
            input "lightningDistVal", "number", title: "Proximity (miles)", defaultValue: 10
            paragraph "<b>Dew Point:</b> Energy fuel for convection."
            input "dewPointVal", "number", title: "Dew Point (¬∞F)", defaultValue: 65
            paragraph "<b>Dark Sky:</b> Lux drop indicating cloud density."
            input "darkSkyDrop", "number", title: "Lux Drop Delta", defaultValue: 3000
  
       }
        section("üåßÔ∏è Precip Load") {
            paragraph "<b>Rain Rate:</b> Intensity adding mass/weight to wind."
            input "stormRainThreshold", "decimal", title: "Rain Rate (in/hr)", defaultValue: 1.0
        }
    }
}

def floodConfigPage() {
    dynamicPage(name: "floodConfigPage", title: "üåä FLOOD CALIBRATION") {
        section("Hydraulics") {
          
            paragraph "<b>Runoff Rate:</b> Rain volume exceeding surface drainage."
            input "floodRainRate", "decimal", title: "Runoff Rain Rate (in/hr)", defaultValue: 2.0
            paragraph "<b>Soil Saturation:</b> Calculated ground water capacity."
            input "soilSatLimit", "number", title: "Soil Saturation Limit (%)", defaultValue: 80
        }
    }
}

def frostConfigPage() {
    dynamicPage(name: "frostConfigPage", title: "‚ùÑÔ∏è FROST CALIBRATION") {
        
section("Thermodynamics") {
            paragraph "<b>Freeze Temp:</b> Boundary layer temp for frost formation."
            input "frostTempThreshold", "number", title: "Freeze Temp (¬∞F)", defaultValue: 37
            paragraph "<b>Vapor Limit:</b> Humidity required for ice deposition."
            input "frostHumThreshold", "number", title: "Frost Vapor Limit (%)", defaultValue: 70
        
    
            // [NEW] Added Vapor Load Max Temp Threshold Setting
            paragraph "<b>Vapor Max Temp:</b> Temp ceiling to count Vapor Load as a risk factor."
            input "frostVaporTempMax", "number", title: "Vapor Load Max Temp (¬∞F)", defaultValue: 50, description: "Humidity only counts as risk below this temp"
       
            paragraph "<b>Thermal Crash:</b> Rapid temp drop rate (Radiative Cooling)."
            input "tempDropVal", "decimal", title: "Thermal Crash Rate (¬∞F/hr)", defaultValue: 4.0
        }
    }
}

def weightConfigPage() {
    dynamicPage(name: "weightConfigPage", title: "‚öñÔ∏è DNA WEIGHTING") {
        section("‚ÑπÔ∏è Logic Explanation") {
            paragraph "Default weights sum to 100%. Changing these will override the standard algorithm."
        }
        section("üå™Ô∏è Storm Weights (Total 100)") {
             input "weightGust", "number", title: "Weight: Gust (Def: 15)", required: false
             input "weightWind", "number", title: "Weight: Wind (Def: 5)", required: false
             input "weightStormRain", "number", title: "Weight: Storm Rain (Def: 10)", required: false
      
             input "weightLight", "number", title: "Weight: Lightning (Def: 20)", required: false
             input "weightProx", "number", title: "Weight: Proximity (Def: 15)", required: false
             input "weightDew", "number", title: "Weight: Dew Point (Def: 5)", required: false
             input "weightDarkSky", "number", title: "Weight: Dark Sky (Def: 20)", required: false
          
   input "weightWindDir", "number", title: "Weight: Vector (Def: 10)", required: false
        }
        section("üåä Flood Weights (Total 100)") {
             input "weightRunoff", "number", title: "Weight: Runoff (Def: 50)", required: false
             input "weightSat", "number", title: "Weight: Saturation (Def: 50)", required: false
        }
        section("‚ùÑÔ∏è Frost Weights (Total 100)") {
  
       
             input "weightFrostTemp", "number", title: "Weight: Frost Temp (Def: 40)", required: false
             input "weightFrostHum", "number", title: "Weight: Frost Humid (Def: 30)", required: false
             input "weightColdAdv", "number", title: "Weight: Cold Advection (Def: 20)", required: false
             input "weightCrash", "number", title: "Weight: Temp Crash (Def: 10)", required: false
 
  
      }
    }
}

def systemConfigPage() {
  
   dynamicPage(name: "systemConfigPage", title: "‚öôÔ∏è SYSTEM & ALERTS") {
        section("‚è±Ô∏è Sensor Logging") {
            paragraph """<div style='background:#e3f2fd; padding:10px; border-left:4px solid #1976d2; font-size:0.8em;'><b>‚ÑπÔ∏è DEEP DIVE: POLLING INTERVAL</b><br>This setting controls how often Trajectory Labs wakes up to fetch sensor data and run physics calculations.<br>‚Ä¢ <b>1-5 Mins:</b> Maximum reaction speed for fast-moving storms. Higher battery drain.<br>‚Ä¢ <b>15 Mins:</b> Balanced standard.<br>‚Ä¢ <b>30-60 Mins:</b> Battery saving mode. Note: Fast flash floods may be detected late.</div>"""
            input "pollInterval", "enum", title: "Update Frequency (Minutes)", options: ["1","5","10","15","30","45","60"], defaultValue: "15", required: true
        }
        
        section("‚è±Ô∏è Trending Options") {
            paragraph "<b>Logic Definition:</b> This setting determines how far back the system looks to calculate the 'Rate of Change' (Slope).\n‚Ä¢ <b>Short (1-15m):</b> Highly reactive, detects sudden spikes, but may trigger false positives.\n‚Ä¢ <b>Long (30-60m):</b> Smoother, requires sustained pressure to trigger, filters out noise."
            input "trendTimeSelect", "enum", title: "‚è±Ô∏è Trend Window (Minutes)", options: ["1","5","10","15","30","45","60"], defaultValue: "60", description: "Select time window for RoC calculations.", required: true
        }
        
        section("üîî Notification Preferences") {
            paragraph "Select which events send Push Notifications and when."
          
            def notifOptions = ["Disabled", "Active Only", "Active & All Clear"]
            
            input "notifyStorm", "enum", title: "üå™Ô∏è Storm Alerts", options: notifOptions, defaultValue: "Active Only", required: true
            paragraph "<div style='font-size:0.75em; color:#555; margin-left:20px; font-style:italic;'><b>Message Preview:</b><br>üö® STORM ALARM ACTIVE<br>Why: Score 85% > 60%<br>Factors: Gusts, Rain, Lightning</div>"
            
            input "notifyFlood", "enum", title: "üåä Flood Alerts", options: notifOptions, defaultValue: "Active Only", required: true
            paragraph "<div style='font-size:0.75em; color:#555; margin-left:20px; font-style:italic;'><b>Message Preview:</b><br>üåä FLOOD ALARM ACTIVE<br>Why: Score 75% > 70%<br>Factors: Runoff, Saturation</div>"
            
            input "notifyFrost", "enum", title: "‚ùÑÔ∏è Frost Alerts", options: notifOptions, defaultValue: "Active Only", required: true
            paragraph "<div style='font-size:0.75em; color:#555; margin-left:20px; font-style:italic;'><b>Message Preview:</b><br>‚ùÑÔ∏è FROST ALARM ACTIVE<br>Why: Wet Bulb 31¬∞F <= 32¬∞F<br>Factors: Wet Bulb, Temp</div>"
            
            input "notifyPredStorm", "enum", title: "üîÆ Pre-Storm Watch", options: notifOptions, defaultValue: "Active Only", required: true
            paragraph "<div style='font-size:0.75em; color:#555; margin-left:20px; font-style:italic;'><b>Message Preview:</b><br>üîÆ PRE-STORM WATCH ACTIVE<br>Why: Trend Rising > 50%<br>Factors: Gusts</div>"
            
            input "notifyPredFlood", "enum", title: "üîÆ Pre-Flood Watch", options: notifOptions, defaultValue: "Active Only", required: true
            input "notifyPredFrost", "enum", title: "üîÆ Pre-Frost Watch", options: notifOptions, defaultValue: "Active Only", required: true
        }

        section("üéöÔ∏è Trigger Sensitivity") {
        
            input "stormTriggerPct", "number", title: "üå™Ô∏è Storm Switch ON (%)", defaultValue: 60, range: "1..100"
            input "floodTriggerPct", "number", title: "üåä Flood Switch ON (%)", defaultValue: 70, range: "1..100"
            input "frostTriggerPct", "number", title: "‚ùÑÔ∏è Frost Switch ON (%)", defaultValue: 60, range: "1..100"
        
            input "hysteresisVal", "number", title: "‚è±Ô∏è Off Hysteresis (%)", defaultValue: 5, range: "1..20"
     
   }
        section("üîÆ Predictive Sensitivity") {
            paragraph "Thresholds for pre-emptive warnings (1 Hour Forecast)."
            input "predStormTriggerPct", "number", title: "üîÆ Pre-Storm Switch ON (%)", defaultValue: 50
            input "predFloodTriggerPct", "number", title: "üîÆ Pre-Flood Switch ON (%)", defaultValue: 50
   
             input "predFrostTriggerPct", "number", title: "üîÆ Pre-Frost Switch ON (%)", defaultValue: 50
            input "predGustVal", "number", title: "Override: Pred Gust (mph)", defaultValue: 45
            input "predFrostTempVal", "number", title: "Override: Pred Frost (¬∞F)", defaultValue: 32
            input "predTempDropVal", "number", title: "Override: Temp Drop (¬∞F/hr)", defaultValue: 3.0
        }
        section("üö´ Exclusions") 
{
            input "excludeWind", "bool", title: "Exclude Wind?", defaultValue: false
            input "excludeRain", "bool", title: "Exclude Rain?", defaultValue: false
            input "excludeLux", "bool", title: "Exclude Lux?", defaultValue: false
            input "excludeLightning", "bool", title: "Exclude Lightning?", defaultValue: false
        }
        section("Hardware") {
       
             input "tempOffset", "decimal", title: "Temp Offset", defaultValue: 0.0
            input "notifDevice", "capability.notification", title: "Notify Devices", multiple: true
            input "showEmergProcs", "bool", title: "Show Emergency Protocols?", defaultValue: true
            input "pauseSwitch", "capability.switch", title: "‚õî External Pause Switch (Optional)", required: false, description: "If ON, system logic is halted."
            input "hardResetBtn", "button", title: "üí£ WIPE ALL DATA", width: 12
       
 }
    }
}

def dataLogPage() {
    dynamicPage(name: "dataLogPage", title: "üìú DATA LOG INSPECTOR") {
   
     section("üå°Ô∏è THERMAL") {
            paragraph generateLogTable("Temp History", state.histTemp, "¬∞F")
            paragraph generateLogTable("Humidity History", state.histHum, "%")
        }
        section("üí® KINETIC") {
            paragraph generateLogTable("Wind Speed", state.histWind, " mph")
     
       paragraph generateLogTable("Gusts", state.histGust, " mph")
        }
  
       section("üåßÔ∏è PRECIP") {
            paragraph generateLogTable("Rain Rate", state.histRain, " in/hr")
        }
        section() {
            input "refreshLogs", "button", title: "üîÑ REFRESH", width: 12, submitOnChange: true
        }
    }
}
